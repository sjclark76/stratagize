// @ts-nocheck
/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Strava API v3
 * The [Swagger Playground](https://developers.strava.com/playground) is the easiest way to familiarize yourself with the Strava API by submitting HTTP requests and observing the responses before you write any client code. It will show what a response will look like with different endpoints depending on the authorization scope you receive from your athletes. To use the Playground, go to https://www.strava.com/settings/api and change your “Authorization Callback Domain” to developers.strava.com. Please note, we only support Swagger 2.0. There is a known issue where you can only select one scope at a time. For more information, please check the section “client code” at https://developers.strava.com/docs.
 *
 * OpenAPI spec version: 3.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as url from 'url';
import * as portableFetch from 'portable-fetch';
import { Configuration } from './configuration';

const BASE_PATH = 'https://www.strava.com/api/v3'.replace(/\/+$/, '');

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|'
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = portableFetch
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name: 'RequiredError';
  constructor(
    public field: string,
    msg?: string
  ) {
    super(msg);
  }
}

/**
 * A set of rolled-up statistics and totals for an athlete
 * @export
 * @interface ActivityStats
 */
export interface ActivityStats {
  /**
   * The longest distance ridden by the athlete.
   * @type {number}
   * @memberof ActivityStats
   */
  biggest_ride_distance?: number;
  /**
   * The highest climb ridden by the athlete.
   * @type {number}
   * @memberof ActivityStats
   */
  biggest_climb_elevation_gain?: number;
  /**
   * The recent (last 4 weeks) ride stats for the athlete.
   * @type {ActivityTotal}
   * @memberof ActivityStats
   */
  recent_ride_totals?: ActivityTotal;
  /**
   * The recent (last 4 weeks) run stats for the athlete.
   * @type {ActivityTotal}
   * @memberof ActivityStats
   */
  recent_run_totals?: ActivityTotal;
  /**
   * The recent (last 4 weeks) swim stats for the athlete.
   * @type {ActivityTotal}
   * @memberof ActivityStats
   */
  recent_swim_totals?: ActivityTotal;
  /**
   * The year to date ride stats for the athlete.
   * @type {ActivityTotal}
   * @memberof ActivityStats
   */
  ytd_ride_totals?: ActivityTotal;
  /**
   * The year to date run stats for the athlete.
   * @type {ActivityTotal}
   * @memberof ActivityStats
   */
  ytd_run_totals?: ActivityTotal;
  /**
   * The year to date swim stats for the athlete.
   * @type {ActivityTotal}
   * @memberof ActivityStats
   */
  ytd_swim_totals?: ActivityTotal;
  /**
   * The all time ride stats for the athlete.
   * @type {ActivityTotal}
   * @memberof ActivityStats
   */
  all_ride_totals?: ActivityTotal;
  /**
   * The all time run stats for the athlete.
   * @type {ActivityTotal}
   * @memberof ActivityStats
   */
  all_run_totals?: ActivityTotal;
  /**
   * The all time swim stats for the athlete.
   * @type {ActivityTotal}
   * @memberof ActivityStats
   */
  all_swim_totals?: ActivityTotal;
}

/**
 * A roll-up of metrics pertaining to a set of activities. Values are in seconds and meters.
 * @export
 * @interface ActivityTotal
 */
export interface ActivityTotal {
  /**
   * The number of activities considered in this total.
   * @type {number}
   * @memberof ActivityTotal
   */
  count?: number;
  /**
   * The total distance covered by the considered activities.
   * @type {number}
   * @memberof ActivityTotal
   */
  distance?: number;
  /**
   * The total moving time of the considered activities.
   * @type {number}
   * @memberof ActivityTotal
   */
  moving_time?: number;
  /**
   * The total elapsed time of the considered activities.
   * @type {number}
   * @memberof ActivityTotal
   */
  elapsed_time?: number;
  /**
   * The total elevation gain of the considered activities.
   * @type {number}
   * @memberof ActivityTotal
   */
  elevation_gain?: number;
  /**
   * The total number of achievements of the considered activities.
   * @type {number}
   * @memberof ActivityTotal
   */
  achievement_count?: number;
}

/**
 * An enumeration of the types an activity may have. Note that this enumeration does not include new sport types (e.g. MountainBikeRide, EMountainBikeRide), activities with these sport types will have the corresponding activity type (e.g. Ride for MountainBikeRide, EBikeRide for EMountainBikeRide)
 * @export
 * @enum {string}
 */
export enum ActivityType {
  AlpineSki = <any>'AlpineSki',
  BackcountrySki = <any>'BackcountrySki',
  Canoeing = <any>'Canoeing',
  Crossfit = <any>'Crossfit',
  EBikeRide = <any>'EBikeRide',
  Elliptical = <any>'Elliptical',
  Golf = <any>'Golf',
  Handcycle = <any>'Handcycle',
  Hike = <any>'Hike',
  IceSkate = <any>'IceSkate',
  InlineSkate = <any>'InlineSkate',
  Kayaking = <any>'Kayaking',
  Kitesurf = <any>'Kitesurf',
  NordicSki = <any>'NordicSki',
  Ride = <any>'Ride',
  RockClimbing = <any>'RockClimbing',
  RollerSki = <any>'RollerSki',
  Rowing = <any>'Rowing',
  Run = <any>'Run',
  Sail = <any>'Sail',
  Skateboard = <any>'Skateboard',
  Snowboard = <any>'Snowboard',
  Snowshoe = <any>'Snowshoe',
  Soccer = <any>'Soccer',
  StairStepper = <any>'StairStepper',
  StandUpPaddling = <any>'StandUpPaddling',
  Surfing = <any>'Surfing',
  Swim = <any>'Swim',
  Velomobile = <any>'Velomobile',
  VirtualRide = <any>'VirtualRide',
  VirtualRun = <any>'VirtualRun',
  Walk = <any>'Walk',
  WeightTraining = <any>'WeightTraining',
  Wheelchair = <any>'Wheelchair',
  Windsurf = <any>'Windsurf',
  Workout = <any>'Workout',
  Yoga = <any>'Yoga'
}

/**
 *
 * @export
 * @interface ActivityZone
 */
export interface ActivityZone {
  /**
   *
   * @type {number}
   * @memberof ActivityZone
   */
  score?: number;
  /**
   *
   * @type {TimedZoneDistribution}
   * @memberof ActivityZone
   */
  distribution_buckets?: TimedZoneDistribution;
  /**
   *
   * @type {string}
   * @memberof ActivityZone
   */
  type?: ActivityZone.TypeEnum;
  /**
   *
   * @type {boolean}
   * @memberof ActivityZone
   */
  sensor_based?: boolean;
  /**
   *
   * @type {number}
   * @memberof ActivityZone
   */
  points?: number;
  /**
   *
   * @type {boolean}
   * @memberof ActivityZone
   */
  custom_zones?: boolean;
  /**
   *
   * @type {number}
   * @memberof ActivityZone
   */
  max?: number;
}

/**
 * @export
 * @namespace ActivityZone
 */
export namespace ActivityZone {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    Heartrate = <any>'heartrate',
    Power = <any>'power'
  }
}

/**
 *
 * @export
 * @interface AltitudeStream
 */
export interface AltitudeStream extends BaseStream {
  /**
   * The sequence of altitude values for this stream, in meters
   * @type {Array<number>}
   * @memberof AltitudeStream
   */
  data?: Array<number>;
}

/**
 * @export
 * @namespace AltitudeStream
 */
export namespace AltitudeStream {}

/**
 *
 * @export
 * @interface BaseStream
 */
export interface BaseStream {
  /**
   * The number of data points in this stream
   * @type {number}
   * @memberof BaseStream
   */
  original_size?: number;
  /**
   * The level of detail (sampling) in which this stream was returned
   * @type {string}
   * @memberof BaseStream
   */
  resolution?: BaseStream.ResolutionEnum;
  /**
   * The base series used in the case the stream was downsampled
   * @type {string}
   * @memberof BaseStream
   */
  series_type?: BaseStream.SeriesTypeEnum;
}

/**
 * @export
 * @namespace BaseStream
 */
export namespace BaseStream {
  /**
   * @export
   * @enum {string}
   */
  export enum ResolutionEnum {
    Low = <any>'low',
    Medium = <any>'medium',
    High = <any>'high'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum SeriesTypeEnum {
    Distance = <any>'distance',
    Time = <any>'time'
  }
}

/**
 *
 * @export
 * @interface CadenceStream
 */
export interface CadenceStream extends BaseStream {
  /**
   * The sequence of cadence values for this stream, in rotations per minute
   * @type {Array<number>}
   * @memberof CadenceStream
   */
  data?: Array<number>;
}

/**
 * @export
 * @namespace CadenceStream
 */
export namespace CadenceStream {}

/**
 *
 * @export
 * @interface ClubActivity
 */
export interface ClubActivity {
  /**
   *
   * @type {MetaAthlete}
   * @memberof ClubActivity
   */
  athlete?: MetaAthlete;
  /**
   * The name of the activity
   * @type {string}
   * @memberof ClubActivity
   */
  name?: string;
  /**
   * The activity's distance, in meters
   * @type {number}
   * @memberof ClubActivity
   */
  distance?: number;
  /**
   * The activity's moving time, in seconds
   * @type {number}
   * @memberof ClubActivity
   */
  moving_time?: number;
  /**
   * The activity's elapsed time, in seconds
   * @type {number}
   * @memberof ClubActivity
   */
  elapsed_time?: number;
  /**
   * The activity's total elevation gain.
   * @type {number}
   * @memberof ClubActivity
   */
  total_elevation_gain?: number;
  /**
   * Deprecated. Prefer to use sport_type
   * @type {ActivityType}
   * @memberof ClubActivity
   */
  type?: ActivityType;
  /**
   *
   * @type {SportType}
   * @memberof ClubActivity
   */
  sport_type?: SportType;
  /**
   * The activity's workout type
   * @type {number}
   * @memberof ClubActivity
   */
  workout_type?: number;
}

/**
 *
 * @export
 * @interface ClubAthlete
 */
export interface ClubAthlete {
  /**
   * Resource state, indicates level of detail. Possible values: 1 -> \"meta\", 2 -> \"summary\", 3 -> \"detail\"
   * @type {number}
   * @memberof ClubAthlete
   */
  resource_state?: number;
  /**
   * The athlete's first name.
   * @type {string}
   * @memberof ClubAthlete
   */
  firstname?: string;
  /**
   * The athlete's last initial.
   * @type {string}
   * @memberof ClubAthlete
   */
  lastname?: string;
  /**
   * The athlete's member status.
   * @type {string}
   * @memberof ClubAthlete
   */
  member?: string;
  /**
   * Whether the athlete is a club admin.
   * @type {boolean}
   * @memberof ClubAthlete
   */
  admin?: boolean;
  /**
   * Whether the athlete is club owner.
   * @type {boolean}
   * @memberof ClubAthlete
   */
  owner?: boolean;
}

/**
 *
 * @export
 * @interface Comment
 */
export interface Comment {
  /**
   * The unique identifier of this comment
   * @type {number}
   * @memberof Comment
   */
  id?: number;
  /**
   * The identifier of the activity this comment is related to
   * @type {number}
   * @memberof Comment
   */
  activity_id?: number;
  /**
   * The content of the comment
   * @type {string}
   * @memberof Comment
   */
  text?: string;
  /**
   *
   * @type {SummaryAthlete}
   * @memberof Comment
   */
  athlete?: SummaryAthlete;
  /**
   * The time at which this comment was created.
   * @type {Date}
   * @memberof Comment
   */
  created_at?: Date;
}

/**
 *
 * @export
 * @interface DetailedActivity
 */
export interface DetailedActivity extends SummaryActivity {
  /**
   * The description of the activity
   * @type {string}
   * @memberof DetailedActivity
   */
  description?: string;
  /**
   *
   * @type {PhotosSummary}
   * @memberof DetailedActivity
   */
  photos?: PhotosSummary;
  /**
   *
   * @type {SummaryGear}
   * @memberof DetailedActivity
   */
  gear?: SummaryGear;
  /**
   * The number of kilocalories consumed during this activity
   * @type {number}
   * @memberof DetailedActivity
   */
  calories?: number;
  /**
   *
   * @type {Array<DetailedSegmentEffort>}
   * @memberof DetailedActivity
   */
  segment_efforts?: Array<DetailedSegmentEffort>;
  /**
   * The name of the device used to record the activity
   * @type {string}
   * @memberof DetailedActivity
   */
  device_name?: string;
  /**
   * The token used to embed a Strava activity
   * @type {string}
   * @memberof DetailedActivity
   */
  embed_token?: string;
  /**
   * The splits of this activity in metric units (for runs)
   * @type {Array<Split>}
   * @memberof DetailedActivity
   */
  splits_metric?: Array<Split>;
  /**
   * The splits of this activity in imperial units (for runs)
   * @type {Array<Split>}
   * @memberof DetailedActivity
   */
  splits_standard?: Array<Split>;
  /**
   *
   * @type {Array<Lap>}
   * @memberof DetailedActivity
   */
  laps?: Array<Lap>;
  /**
   *
   * @type {Array<DetailedSegmentEffort>}
   * @memberof DetailedActivity
   */
  best_efforts?: Array<DetailedSegmentEffort>;
}

/**
 *
 * @export
 * @interface DetailedAthlete
 */
export interface DetailedAthlete extends SummaryAthlete {
  /**
   * The athlete's follower count.
   * @type {number}
   * @memberof DetailedAthlete
   */
  follower_count?: number;
  /**
   * The athlete's friend count.
   * @type {number}
   * @memberof DetailedAthlete
   */
  friend_count?: number;
  /**
   * The athlete's preferred unit system.
   * @type {string}
   * @memberof DetailedAthlete
   */
  measurement_preference?: DetailedAthlete.MeasurementPreferenceEnum;
  /**
   * The athlete's FTP (Functional Threshold Power).
   * @type {number}
   * @memberof DetailedAthlete
   */
  ftp?: number;
  /**
   * The athlete's weight.
   * @type {number}
   * @memberof DetailedAthlete
   */
  weight?: number;
  /**
   * The athlete's clubs.
   * @type {Array<SummaryClub>}
   * @memberof DetailedAthlete
   */
  clubs?: Array<SummaryClub>;
  /**
   * The athlete's bikes.
   * @type {Array<SummaryGear>}
   * @memberof DetailedAthlete
   */
  bikes?: Array<SummaryGear>;
  /**
   * The athlete's shoes.
   * @type {Array<SummaryGear>}
   * @memberof DetailedAthlete
   */
  shoes?: Array<SummaryGear>;
}

/**
 * @export
 * @namespace DetailedAthlete
 */
export namespace DetailedAthlete {
  /**
   * @export
   * @enum {string}
   */
  export enum MeasurementPreferenceEnum {
    Feet = <any>'feet',
    Meters = <any>'meters'
  }
}

/**
 *
 * @export
 * @interface DetailedClub
 */
export interface DetailedClub extends SummaryClub {
  /**
   * The membership status of the logged-in athlete.
   * @type {string}
   * @memberof DetailedClub
   */
  membership?: DetailedClub.MembershipEnum;
  /**
   * Whether the currently logged-in athlete is an administrator of this club.
   * @type {boolean}
   * @memberof DetailedClub
   */
  admin?: boolean;
  /**
   * Whether the currently logged-in athlete is the owner of this club.
   * @type {boolean}
   * @memberof DetailedClub
   */
  owner?: boolean;
  /**
   * The number of athletes in the club that the logged-in athlete follows.
   * @type {number}
   * @memberof DetailedClub
   */
  following_count?: number;
}

/**
 * @export
 * @namespace DetailedClub
 */
export namespace DetailedClub {
  /**
   * @export
   * @enum {string}
   */
  export enum MembershipEnum {
    Member = <any>'member',
    Pending = <any>'pending'
  }
}

/**
 *
 * @export
 * @interface DetailedGear
 */
export interface DetailedGear extends SummaryGear {
  /**
   * The gear's brand name.
   * @type {string}
   * @memberof DetailedGear
   */
  brand_name?: string;
  /**
   * The gear's model name.
   * @type {string}
   * @memberof DetailedGear
   */
  model_name?: string;
  /**
   * The gear's frame type (bike only).
   * @type {number}
   * @memberof DetailedGear
   */
  frame_type?: number;
  /**
   * The gear's description.
   * @type {string}
   * @memberof DetailedGear
   */
  description?: string;
}

/**
 *
 * @export
 * @interface DetailedSegment
 */
export interface DetailedSegment extends SummarySegment {
  /**
   * The time at which the segment was created.
   * @type {Date}
   * @memberof DetailedSegment
   */
  created_at?: Date;
  /**
   * The time at which the segment was last updated.
   * @type {Date}
   * @memberof DetailedSegment
   */
  updated_at?: Date;
  /**
   * The segment's total elevation gain.
   * @type {number}
   * @memberof DetailedSegment
   */
  total_elevation_gain?: number;
  /**
   *
   * @type {PolylineMap}
   * @memberof DetailedSegment
   */
  map?: PolylineMap;
  /**
   * The total number of efforts for this segment
   * @type {number}
   * @memberof DetailedSegment
   */
  effort_count?: number;
  /**
   * The number of unique athletes who have an effort for this segment
   * @type {number}
   * @memberof DetailedSegment
   */
  athlete_count?: number;
  /**
   * Whether this segment is considered hazardous
   * @type {boolean}
   * @memberof DetailedSegment
   */
  hazardous?: boolean;
  /**
   * The number of stars for this segment
   * @type {number}
   * @memberof DetailedSegment
   */
  star_count?: number;
}

/**
 * @export
 * @namespace DetailedSegment
 */
export namespace DetailedSegment {}

/**
 *
 * @export
 * @interface DetailedSegmentEffort
 */
export interface DetailedSegmentEffort extends SummarySegmentEffort {
  /**
   * The name of the segment on which this effort was performed
   * @type {string}
   * @memberof DetailedSegmentEffort
   */
  name?: string;
  /**
   *
   * @type {MetaActivity}
   * @memberof DetailedSegmentEffort
   */
  activity?: MetaActivity;
  /**
   *
   * @type {MetaAthlete}
   * @memberof DetailedSegmentEffort
   */
  athlete?: MetaAthlete;
  /**
   * The effort's moving time
   * @type {number}
   * @memberof DetailedSegmentEffort
   */
  moving_time?: number;
  /**
   * The start index of this effort in its activity's stream
   * @type {number}
   * @memberof DetailedSegmentEffort
   */
  start_index?: number;
  /**
   * The end index of this effort in its activity's stream
   * @type {number}
   * @memberof DetailedSegmentEffort
   */
  end_index?: number;
  /**
   * The effort's average cadence
   * @type {number}
   * @memberof DetailedSegmentEffort
   */
  average_cadence?: number;
  /**
   * The average wattage of this effort
   * @type {number}
   * @memberof DetailedSegmentEffort
   */
  average_watts?: number;
  /**
   * For riding efforts, whether the wattage was reported by a dedicated recording device
   * @type {boolean}
   * @memberof DetailedSegmentEffort
   */
  device_watts?: boolean;
  /**
   * The heart heart rate of the athlete during this effort
   * @type {number}
   * @memberof DetailedSegmentEffort
   */
  average_heartrate?: number;
  /**
   * The maximum heart rate of the athlete during this effort
   * @type {number}
   * @memberof DetailedSegmentEffort
   */
  max_heartrate?: number;
  /**
   *
   * @type {SummarySegment}
   * @memberof DetailedSegmentEffort
   */
  segment?: SummarySegment;
  /**
   * The rank of the effort on the global leaderboard if it belongs in the top 10 at the time of upload
   * @type {number}
   * @memberof DetailedSegmentEffort
   */
  kom_rank?: number;
  /**
   * The rank of the effort on the athlete's leaderboard if it belongs in the top 3 at the time of upload
   * @type {number}
   * @memberof DetailedSegmentEffort
   */
  pr_rank?: number;
  /**
   * Whether this effort should be hidden when viewed within an activity
   * @type {boolean}
   * @memberof DetailedSegmentEffort
   */
  hidden?: boolean;
}

/**
 *
 * @export
 * @interface DistanceStream
 */
export interface DistanceStream extends BaseStream {
  /**
   * The sequence of distance values for this stream, in meters
   * @type {Array<number>}
   * @memberof DistanceStream
   */
  data?: Array<number>;
}

/**
 * @export
 * @namespace DistanceStream
 */
export namespace DistanceStream {}

/**
 *
 * @export
 * @interface ExplorerResponse
 */
export interface ExplorerResponse {
  /**
   * The set of segments matching an explorer request
   * @type {Array<ExplorerSegment>}
   * @memberof ExplorerResponse
   */
  segments?: Array<ExplorerSegment>;
}

/**
 *
 * @export
 * @interface ExplorerSegment
 */
export interface ExplorerSegment {
  /**
   * The unique identifier of this segment
   * @type {number}
   * @memberof ExplorerSegment
   */
  id?: number;
  /**
   * The name of this segment
   * @type {string}
   * @memberof ExplorerSegment
   */
  name?: string;
  /**
   * The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catégorie, 0 is uncategorized in climb_category. If climb_category = 5, climb_category_desc = HC. If climb_category = 2, climb_category_desc = 3.
   * @type {number}
   * @memberof ExplorerSegment
   */
  climb_category?: number;
  /**
   * The description for the category of the climb
   * @type {string}
   * @memberof ExplorerSegment
   */
  climb_category_desc?: ExplorerSegment.ClimbCategoryDescEnum;
  /**
   * The segment's average grade, in percents
   * @type {number}
   * @memberof ExplorerSegment
   */
  avg_grade?: number;
  /**
   *
   * @type {LatLng}
   * @memberof ExplorerSegment
   */
  start_latlng?: LatLng;
  /**
   *
   * @type {LatLng}
   * @memberof ExplorerSegment
   */
  end_latlng?: LatLng;
  /**
   * The segments's evelation difference, in meters
   * @type {number}
   * @memberof ExplorerSegment
   */
  elev_difference?: number;
  /**
   * The segment's distance, in meters
   * @type {number}
   * @memberof ExplorerSegment
   */
  distance?: number;
  /**
   * The polyline of the segment
   * @type {string}
   * @memberof ExplorerSegment
   */
  points?: string;
}

/**
 * @export
 * @namespace ExplorerSegment
 */
export namespace ExplorerSegment {
  /**
   * @export
   * @enum {string}
   */
  export enum ClimbCategoryDescEnum {
    NC = <any>'NC',
    _4 = <any>'4',
    _3 = <any>'3',
    _2 = <any>'2',
    _1 = <any>'1',
    HC = <any>'HC'
  }
}

/**
 * Encapsulates the errors that may be returned from the API.
 * @export
 * @interface Fault
 */
export interface Fault {
  /**
   * The set of specific errors associated with this fault, if any.
   * @type {Array<Error>}
   * @memberof Fault
   */
  errors?: Array<Error>;
  /**
   * The message of the fault.
   * @type {string}
   * @memberof Fault
   */
  message?: string;
}

/**
 *
 * @export
 * @interface HeartRateZoneRanges
 */
export interface HeartRateZoneRanges {
  /**
   * Whether the athlete has set their own custom heart rate zones
   * @type {boolean}
   * @memberof HeartRateZoneRanges
   */
  custom_zones?: boolean;
  /**
   *
   * @type {ZoneRanges}
   * @memberof HeartRateZoneRanges
   */
  zones?: ZoneRanges;
}

/**
 *
 * @export
 * @interface HeartrateStream
 */
export interface HeartrateStream extends BaseStream {
  /**
   * The sequence of heart rate values for this stream, in beats per minute
   * @type {Array<number>}
   * @memberof HeartrateStream
   */
  data?: Array<number>;
}

/**
 * @export
 * @namespace HeartrateStream
 */
export namespace HeartrateStream {}

/**
 *
 * @export
 * @interface Lap
 */
export interface Lap {
  /**
   * The unique identifier of this lap
   * @type {number}
   * @memberof Lap
   */
  id?: number;
  /**
   *
   * @type {MetaActivity}
   * @memberof Lap
   */
  activity?: MetaActivity;
  /**
   *
   * @type {MetaAthlete}
   * @memberof Lap
   */
  athlete?: MetaAthlete;
  /**
   * The lap's average cadence
   * @type {number}
   * @memberof Lap
   */
  average_cadence?: number;
  /**
   * The lap's average speed
   * @type {number}
   * @memberof Lap
   */
  average_speed?: number;
  /**
   * The lap's distance, in meters
   * @type {number}
   * @memberof Lap
   */
  distance?: number;
  /**
   * The lap's elapsed time, in seconds
   * @type {number}
   * @memberof Lap
   */
  elapsed_time?: number;
  /**
   * The start index of this effort in its activity's stream
   * @type {number}
   * @memberof Lap
   */
  start_index?: number;
  /**
   * The end index of this effort in its activity's stream
   * @type {number}
   * @memberof Lap
   */
  end_index?: number;
  /**
   * The index of this lap in the activity it belongs to
   * @type {number}
   * @memberof Lap
   */
  lap_index?: number;
  /**
   * The maximum speed of this lat, in meters per second
   * @type {number}
   * @memberof Lap
   */
  max_speed?: number;
  /**
   * The lap's moving time, in seconds
   * @type {number}
   * @memberof Lap
   */
  moving_time?: number;
  /**
   * The name of the lap
   * @type {string}
   * @memberof Lap
   */
  name?: string;
  /**
   * The athlete's pace zone during this lap
   * @type {number}
   * @memberof Lap
   */
  pace_zone?: number;
  /**
   *
   * @type {number}
   * @memberof Lap
   */
  split?: number;
  /**
   * The time at which the lap was started.
   * @type {Date}
   * @memberof Lap
   */
  start_date?: Date;
  /**
   * The time at which the lap was started in the local timezone.
   * @type {Date}
   * @memberof Lap
   */
  start_date_local?: Date;
  /**
   * The elevation gain of this lap, in meters
   * @type {number}
   * @memberof Lap
   */
  total_elevation_gain?: number;
}

/**
 * A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
 * @export
 * @interface LatLng
 */
export interface LatLng extends Array<number> {}

/**
 *
 * @export
 * @interface LatLngStream
 */
export interface LatLngStream extends BaseStream {
  /**
   * The sequence of lat/long values for this stream
   * @type {Array<LatLng>}
   * @memberof LatLngStream
   */
  data?: Array<LatLng>;
}

/**
 * @export
 * @namespace LatLngStream
 */
export namespace LatLngStream {}

/**
 *
 * @export
 * @interface MetaActivity
 */
export interface MetaActivity {
  /**
   * The unique identifier of the activity
   * @type {number}
   * @memberof MetaActivity
   */
  id?: number;
}

/**
 *
 * @export
 * @interface MetaAthlete
 */
export interface MetaAthlete {
  /**
   * The unique identifier of the athlete
   * @type {number}
   * @memberof MetaAthlete
   */
  id?: number;
}

/**
 *
 * @export
 * @interface MetaClub
 */
export interface MetaClub {
  /**
   * The club's unique identifier.
   * @type {number}
   * @memberof MetaClub
   */
  id?: number;
  /**
   * Resource state, indicates level of detail. Possible values: 1 -> \"meta\", 2 -> \"summary\", 3 -> \"detail\"
   * @type {number}
   * @memberof MetaClub
   */
  resource_state?: number;
  /**
   * The club's name.
   * @type {string}
   * @memberof MetaClub
   */
  name?: string;
}

/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   * The code associated with this error.
   * @type {string}
   * @memberof ModelError
   */
  code?: string;
  /**
   * The specific field or aspect of the resource associated with this error.
   * @type {string}
   * @memberof ModelError
   */
  field?: string;
  /**
   * The type of resource associated with this error.
   * @type {string}
   * @memberof ModelError
   */
  resource?: string;
}

/**
 *
 * @export
 * @interface MovingStream
 */
export interface MovingStream extends BaseStream {
  /**
   * The sequence of moving values for this stream, as boolean values
   * @type {Array<boolean>}
   * @memberof MovingStream
   */
  data?: Array<boolean>;
}

/**
 * @export
 * @namespace MovingStream
 */
export namespace MovingStream {}

/**
 *
 * @export
 * @interface PhotosSummary
 */
export interface PhotosSummary {
  /**
   * The number of photos
   * @type {number}
   * @memberof PhotosSummary
   */
  count?: number;
  /**
   *
   * @type {PhotosSummaryPrimary}
   * @memberof PhotosSummary
   */
  primary?: PhotosSummaryPrimary;
}

/**
 *
 * @export
 * @interface PhotosSummaryPrimary
 */
export interface PhotosSummaryPrimary {
  /**
   *
   * @type {number}
   * @memberof PhotosSummaryPrimary
   */
  id?: number;
  /**
   *
   * @type {number}
   * @memberof PhotosSummaryPrimary
   */
  source?: number;
  /**
   *
   * @type {string}
   * @memberof PhotosSummaryPrimary
   */
  unique_id?: string;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof PhotosSummaryPrimary
   */
  urls?: { [key: string]: string };
}

/**
 *
 * @export
 * @interface PolylineMap
 */
export interface PolylineMap {
  /**
   * The identifier of the map
   * @type {string}
   * @memberof PolylineMap
   */
  id?: string;
  /**
   * The polyline of the map, only returned on detailed representation of an object
   * @type {string}
   * @memberof PolylineMap
   */
  polyline?: string;
  /**
   * The summary polyline of the map
   * @type {string}
   * @memberof PolylineMap
   */
  summary_polyline?: string;
}

/**
 *
 * @export
 * @interface PowerStream
 */
export interface PowerStream extends BaseStream {
  /**
   * The sequence of power values for this stream, in watts
   * @type {Array<number>}
   * @memberof PowerStream
   */
  data?: Array<number>;
}

/**
 * @export
 * @namespace PowerStream
 */
export namespace PowerStream {}

/**
 *
 * @export
 * @interface PowerZoneRanges
 */
export interface PowerZoneRanges {
  /**
   *
   * @type {ZoneRanges}
   * @memberof PowerZoneRanges
   */
  zones?: ZoneRanges;
}

/**
 *
 * @export
 * @interface Route
 */
export interface Route {
  /**
   *
   * @type {SummaryAthlete}
   * @memberof Route
   */
  athlete?: SummaryAthlete;
  /**
   * The description of the route
   * @type {string}
   * @memberof Route
   */
  description?: string;
  /**
   * The route's distance, in meters
   * @type {number}
   * @memberof Route
   */
  distance?: number;
  /**
   * The route's elevation gain.
   * @type {number}
   * @memberof Route
   */
  elevation_gain?: number;
  /**
   * The unique identifier of this route
   * @type {number}
   * @memberof Route
   */
  id?: number;
  /**
   * The unique identifier of the route in string format
   * @type {string}
   * @memberof Route
   */
  id_str?: string;
  /**
   *
   * @type {PolylineMap}
   * @memberof Route
   */
  map?: PolylineMap;
  /**
   * The name of this route
   * @type {string}
   * @memberof Route
   */
  name?: string;
  /**
   * Whether this route is private
   * @type {boolean}
   * @memberof Route
   */
  _private?: boolean;
  /**
   * Whether this route is starred by the logged-in athlete
   * @type {boolean}
   * @memberof Route
   */
  starred?: boolean;
  /**
   * An epoch timestamp of when the route was created
   * @type {number}
   * @memberof Route
   */
  timestamp?: number;
  /**
   * This route's type (1 for ride, 2 for runs)
   * @type {number}
   * @memberof Route
   */
  type?: number;
  /**
   * This route's sub-type (1 for road, 2 for mountain bike, 3 for cross, 4 for trail, 5 for mixed)
   * @type {number}
   * @memberof Route
   */
  sub_type?: number;
  /**
   * The time at which the route was created
   * @type {Date}
   * @memberof Route
   */
  created_at?: Date;
  /**
   * The time at which the route was last updated
   * @type {Date}
   * @memberof Route
   */
  updated_at?: Date;
  /**
   * Estimated time in seconds for the authenticated athlete to complete route
   * @type {number}
   * @memberof Route
   */
  estimated_moving_time?: number;
  /**
   * The segments traversed by this route
   * @type {Array<SummarySegment>}
   * @memberof Route
   */
  segments?: Array<SummarySegment>;
}

/**
 *
 * @export
 * @interface SmoothGradeStream
 */
export interface SmoothGradeStream extends BaseStream {
  /**
   * The sequence of grade values for this stream, as percents of a grade
   * @type {Array<number>}
   * @memberof SmoothGradeStream
   */
  data?: Array<number>;
}

/**
 * @export
 * @namespace SmoothGradeStream
 */
export namespace SmoothGradeStream {}

/**
 *
 * @export
 * @interface SmoothVelocityStream
 */
export interface SmoothVelocityStream extends BaseStream {
  /**
   * The sequence of velocity values for this stream, in meters per second
   * @type {Array<number>}
   * @memberof SmoothVelocityStream
   */
  data?: Array<number>;
}

/**
 * @export
 * @namespace SmoothVelocityStream
 */
export namespace SmoothVelocityStream {}

/**
 *
 * @export
 * @interface Split
 */
export interface Split {
  /**
   * The average speed of this split, in meters per second
   * @type {number}
   * @memberof Split
   */
  average_speed?: number;
  /**
   * The distance of this split, in meters
   * @type {number}
   * @memberof Split
   */
  distance?: number;
  /**
   * The elapsed time of this split, in seconds
   * @type {number}
   * @memberof Split
   */
  elapsed_time?: number;
  /**
   * The elevation difference of this split, in meters
   * @type {number}
   * @memberof Split
   */
  elevation_difference?: number;
  /**
   * The pacing zone of this split
   * @type {number}
   * @memberof Split
   */
  pace_zone?: number;
  /**
   * The moving time of this split, in seconds
   * @type {number}
   * @memberof Split
   */
  moving_time?: number;
  /**
   * N/A
   * @type {number}
   * @memberof Split
   */
  split?: number;
}

/**
 * An enumeration of the sport types an activity may have. Distinct from ActivityType in that it has new types (e.g. MountainBikeRide)
 * @export
 * @enum {string}
 */
export enum SportType {
  AlpineSki = <any>'AlpineSki',
  BackcountrySki = <any>'BackcountrySki',
  Badminton = <any>'Badminton',
  Canoeing = <any>'Canoeing',
  Crossfit = <any>'Crossfit',
  EBikeRide = <any>'EBikeRide',
  Elliptical = <any>'Elliptical',
  EMountainBikeRide = <any>'EMountainBikeRide',
  Golf = <any>'Golf',
  GravelRide = <any>'GravelRide',
  Handcycle = <any>'Handcycle',
  HighIntensityIntervalTraining = <any>'HighIntensityIntervalTraining',
  Hike = <any>'Hike',
  IceSkate = <any>'IceSkate',
  InlineSkate = <any>'InlineSkate',
  Kayaking = <any>'Kayaking',
  Kitesurf = <any>'Kitesurf',
  MountainBikeRide = <any>'MountainBikeRide',
  NordicSki = <any>'NordicSki',
  Pickleball = <any>'Pickleball',
  Pilates = <any>'Pilates',
  Racquetball = <any>'Racquetball',
  Ride = <any>'Ride',
  RockClimbing = <any>'RockClimbing',
  RollerSki = <any>'RollerSki',
  Rowing = <any>'Rowing',
  Run = <any>'Run',
  Sail = <any>'Sail',
  Skateboard = <any>'Skateboard',
  Snowboard = <any>'Snowboard',
  Snowshoe = <any>'Snowshoe',
  Soccer = <any>'Soccer',
  Squash = <any>'Squash',
  StairStepper = <any>'StairStepper',
  StandUpPaddling = <any>'StandUpPaddling',
  Surfing = <any>'Surfing',
  Swim = <any>'Swim',
  TableTennis = <any>'TableTennis',
  Tennis = <any>'Tennis',
  TrailRun = <any>'TrailRun',
  Velomobile = <any>'Velomobile',
  VirtualRide = <any>'VirtualRide',
  VirtualRow = <any>'VirtualRow',
  VirtualRun = <any>'VirtualRun',
  Walk = <any>'Walk',
  WeightTraining = <any>'WeightTraining',
  Wheelchair = <any>'Wheelchair',
  Windsurf = <any>'Windsurf',
  Workout = <any>'Workout',
  Yoga = <any>'Yoga'
}

/**
 *
 * @export
 * @interface StreamSet
 */
export interface StreamSet {
  /**
   *
   * @type {TimeStream}
   * @memberof StreamSet
   */
  time?: TimeStream;
  /**
   *
   * @type {DistanceStream}
   * @memberof StreamSet
   */
  distance?: DistanceStream;
  /**
   *
   * @type {LatLngStream}
   * @memberof StreamSet
   */
  latlng?: LatLngStream;
  /**
   *
   * @type {AltitudeStream}
   * @memberof StreamSet
   */
  altitude?: AltitudeStream;
  /**
   *
   * @type {SmoothVelocityStream}
   * @memberof StreamSet
   */
  velocity_smooth?: SmoothVelocityStream;
  /**
   *
   * @type {HeartrateStream}
   * @memberof StreamSet
   */
  heartrate?: HeartrateStream;
  /**
   *
   * @type {CadenceStream}
   * @memberof StreamSet
   */
  cadence?: CadenceStream;
  /**
   *
   * @type {PowerStream}
   * @memberof StreamSet
   */
  watts?: PowerStream;
  /**
   *
   * @type {TemperatureStream}
   * @memberof StreamSet
   */
  temp?: TemperatureStream;
  /**
   *
   * @type {MovingStream}
   * @memberof StreamSet
   */
  moving?: MovingStream;
  /**
   *
   * @type {SmoothGradeStream}
   * @memberof StreamSet
   */
  grade_smooth?: SmoothGradeStream;
}

/**
 *
 * @export
 * @interface SummaryActivity
 */
export interface SummaryActivity extends MetaActivity {
  /**
   * The identifier provided at upload time
   * @type {string}
   * @memberof SummaryActivity
   */
  external_id?: string;
  /**
   * The identifier of the upload that resulted in this activity
   * @type {number}
   * @memberof SummaryActivity
   */
  upload_id?: number;
  /**
   *
   * @type {MetaAthlete}
   * @memberof SummaryActivity
   */
  athlete?: MetaAthlete;
  /**
   * The name of the activity
   * @type {string}
   * @memberof SummaryActivity
   */
  name?: string;
  /**
   * The activity's distance, in meters
   * @type {number}
   * @memberof SummaryActivity
   */
  distance?: number;
  /**
   * The activity's moving time, in seconds
   * @type {number}
   * @memberof SummaryActivity
   */
  moving_time?: number;
  /**
   * The activity's elapsed time, in seconds
   * @type {number}
   * @memberof SummaryActivity
   */
  elapsed_time?: number;
  /**
   * The activity's total elevation gain.
   * @type {number}
   * @memberof SummaryActivity
   */
  total_elevation_gain?: number;
  /**
   * The activity's highest elevation, in meters
   * @type {number}
   * @memberof SummaryActivity
   */
  elev_high?: number;
  /**
   * The activity's lowest elevation, in meters
   * @type {number}
   * @memberof SummaryActivity
   */
  elev_low?: number;
  /**
   * Deprecated. Prefer to use sport_type
   * @type {ActivityType}
   * @memberof SummaryActivity
   */
  type?: ActivityType;
  /**
   *
   * @type {SportType}
   * @memberof SummaryActivity
   */
  sport_type?: SportType;
  /**
   * The time at which the activity was started.
   * @type {Date}
   * @memberof SummaryActivity
   */
  start_date?: string;
  /**
   * The time at which the activity was started in the local timezone.
   * @type {Date}
   * @memberof SummaryActivity
   */
  start_date_local?: string;
  /**
   * The timezone of the activity
   * @type {string}
   * @memberof SummaryActivity
   */
  timezone?: string;
  /**
   *
   * @type {LatLng}
   * @memberof SummaryActivity
   */
  start_latlng?: LatLng;
  /**
   *
   * @type {LatLng}
   * @memberof SummaryActivity
   */
  end_latlng?: LatLng;
  /**
   * The number of achievements gained during this activity
   * @type {number}
   * @memberof SummaryActivity
   */
  achievement_count?: number;
  /**
   * The number of kudos given for this activity
   * @type {number}
   * @memberof SummaryActivity
   */
  kudos_count?: number;
  /**
   * The number of comments for this activity
   * @type {number}
   * @memberof SummaryActivity
   */
  comment_count?: number;
  /**
   * The number of athletes for taking part in a group activity
   * @type {number}
   * @memberof SummaryActivity
   */
  athlete_count?: number;
  /**
   * The number of Instagram photos for this activity
   * @type {number}
   * @memberof SummaryActivity
   */
  photo_count?: number;
  /**
   * The number of Instagram and Strava photos for this activity
   * @type {number}
   * @memberof SummaryActivity
   */
  total_photo_count?: number;
  /**
   *
   * @type {PolylineMap}
   * @memberof SummaryActivity
   */
  map?: PolylineMap;
  /**
   * Whether this activity was recorded on a training machine
   * @type {boolean}
   * @memberof SummaryActivity
   */
  trainer?: boolean;
  /**
   * Whether this activity is a commute
   * @type {boolean}
   * @memberof SummaryActivity
   */
  commute?: boolean;
  /**
   * Whether this activity was created manually
   * @type {boolean}
   * @memberof SummaryActivity
   */
  manual?: boolean;
  /**
   * Whether this activity is private
   * @type {boolean}
   * @memberof SummaryActivity
   */
  _private?: boolean;
  /**
   * Whether this activity is flagged
   * @type {boolean}
   * @memberof SummaryActivity
   */
  flagged?: boolean;
  /**
   * The activity's workout type
   * @type {number}
   * @memberof SummaryActivity
   */
  workout_type?: number;
  /**
   * The unique identifier of the upload in string format
   * @type {string}
   * @memberof SummaryActivity
   */
  upload_id_str?: string;
  /**
   * The activity's average speed, in meters per second
   * @type {number}
   * @memberof SummaryActivity
   */
  average_speed?: number;
  /**
   * The activity's max speed, in meters per second
   * @type {number}
   * @memberof SummaryActivity
   */
  max_speed?: number;
  /**
   * Whether the logged-in athlete has kudoed this activity
   * @type {boolean}
   * @memberof SummaryActivity
   */
  has_kudoed?: boolean;
  /**
   * Whether the activity is muted
   * @type {boolean}
   * @memberof SummaryActivity
   */
  hide_from_home?: boolean;
  /**
   * The id of the gear for the activity
   * @type {string}
   * @memberof SummaryActivity
   */
  gear_id?: string;
  /**
   * The total work done in kilojoules during this activity. Rides only
   * @type {number}
   * @memberof SummaryActivity
   */
  kilojoules?: number;
  /**
   * Average power output in watts during this activity. Rides only
   * @type {number}
   * @memberof SummaryActivity
   */
  average_watts?: number;
  /**
   * Whether the watts are from a power meter, false if estimated
   * @type {boolean}
   * @memberof SummaryActivity
   */
  device_watts?: boolean;
  /**
   * Rides with power meter data only
   * @type {number}
   * @memberof SummaryActivity
   */
  max_watts?: number;
  /**
   * Similar to Normalized Power. Rides with power meter data only
   * @type {number}
   * @memberof SummaryActivity
   */
  weighted_average_watts?: number;
}

/**
 *
 * @export
 * @interface SummaryAthlete
 */
export interface SummaryAthlete extends MetaAthlete {
  /**
   * Resource state, indicates level of detail. Possible values: 1 -> \"meta\", 2 -> \"summary\", 3 -> \"detail\"
   * @type {number}
   * @memberof SummaryAthlete
   */
  resource_state?: number;
  /**
   * The athlete's first name.
   * @type {string}
   * @memberof SummaryAthlete
   */
  firstname?: string;
  /**
   * The athlete's last name.
   * @type {string}
   * @memberof SummaryAthlete
   */
  lastname?: string;
  /**
   * URL to a 62x62 pixel profile picture.
   * @type {string}
   * @memberof SummaryAthlete
   */
  profile_medium?: string;
  /**
   * URL to a 124x124 pixel profile picture.
   * @type {string}
   * @memberof SummaryAthlete
   */
  profile?: string;
  /**
   * The athlete's city.
   * @type {string}
   * @memberof SummaryAthlete
   */
  city?: string;
  /**
   * The athlete's state or geographical region.
   * @type {string}
   * @memberof SummaryAthlete
   */
  state?: string;
  /**
   * The athlete's country.
   * @type {string}
   * @memberof SummaryAthlete
   */
  country?: string;
  /**
   * The athlete's sex.
   * @type {string}
   * @memberof SummaryAthlete
   */
  sex?: SummaryAthlete.SexEnum;
  /**
   * Deprecated.  Use summit field instead. Whether the athlete has any Summit subscription.
   * @type {boolean}
   * @memberof SummaryAthlete
   */
  premium?: boolean;
  /**
   * Whether the athlete has any Summit subscription.
   * @type {boolean}
   * @memberof SummaryAthlete
   */
  summit?: boolean;
  /**
   * The time at which the athlete was created.
   * @type {Date}
   * @memberof SummaryAthlete
   */
  created_at?: Date;
  /**
   * The time at which the athlete was last updated.
   * @type {Date}
   * @memberof SummaryAthlete
   */
  updated_at?: Date;
}

/**
 * @export
 * @namespace SummaryAthlete
 */
export namespace SummaryAthlete {
  /**
   * @export
   * @enum {string}
   */
  export enum SexEnum {
    M = <any>'M',
    F = <any>'F'
  }
}

/**
 *
 * @export
 * @interface SummaryClub
 */
export interface SummaryClub extends MetaClub {
  /**
   * URL to a 60x60 pixel profile picture.
   * @type {string}
   * @memberof SummaryClub
   */
  profile_medium?: string;
  /**
   * URL to a ~1185x580 pixel cover photo.
   * @type {string}
   * @memberof SummaryClub
   */
  cover_photo?: string;
  /**
   * URL to a ~360x176  pixel cover photo.
   * @type {string}
   * @memberof SummaryClub
   */
  cover_photo_small?: string;
  /**
   * Deprecated. Prefer to use activity_types.
   * @type {string}
   * @memberof SummaryClub
   */
  sport_type?: SummaryClub.SportTypeEnum;
  /**
   * The activity types that count for a club. This takes precedence over sport_type.
   * @type {Array<ActivityType>}
   * @memberof SummaryClub
   */
  activity_types?: Array<ActivityType>;
  /**
   * The club's city.
   * @type {string}
   * @memberof SummaryClub
   */
  city?: string;
  /**
   * The club's state or geographical region.
   * @type {string}
   * @memberof SummaryClub
   */
  state?: string;
  /**
   * The club's country.
   * @type {string}
   * @memberof SummaryClub
   */
  country?: string;
  /**
   * Whether the club is private.
   * @type {boolean}
   * @memberof SummaryClub
   */
  _private?: boolean;
  /**
   * The club's member count.
   * @type {number}
   * @memberof SummaryClub
   */
  member_count?: number;
  /**
   * Whether the club is featured or not.
   * @type {boolean}
   * @memberof SummaryClub
   */
  featured?: boolean;
  /**
   * Whether the club is verified or not.
   * @type {boolean}
   * @memberof SummaryClub
   */
  verified?: boolean;
  /**
   * The club's vanity URL.
   * @type {string}
   * @memberof SummaryClub
   */
  url?: string;
}

/**
 * @export
 * @namespace SummaryClub
 */
export namespace SummaryClub {
  /**
   * @export
   * @enum {string}
   */
  export enum SportTypeEnum {
    Cycling = <any>'cycling',
    Running = <any>'running',
    Triathlon = <any>'triathlon',
    Other = <any>'other'
  }
}

/**
 *
 * @export
 * @interface SummaryGear
 */
export interface SummaryGear {
  /**
   * The gear's unique identifier.
   * @type {string}
   * @memberof SummaryGear
   */
  id?: string;
  /**
   * Resource state, indicates level of detail. Possible values: 2 -> \"summary\", 3 -> \"detail\"
   * @type {number}
   * @memberof SummaryGear
   */
  resource_state?: number;
  /**
   * Whether this gear's is the owner's default one.
   * @type {boolean}
   * @memberof SummaryGear
   */
  primary?: boolean;
  /**
   * The gear's name.
   * @type {string}
   * @memberof SummaryGear
   */
  name?: string;
  /**
   * The distance logged with this gear.
   * @type {number}
   * @memberof SummaryGear
   */
  distance?: number;
}

/**
 *
 * @export
 * @interface SummaryPRSegmentEffort
 */
export interface SummaryPRSegmentEffort {
  /**
   * The unique identifier of the activity related to the PR effort.
   * @type {number}
   * @memberof SummaryPRSegmentEffort
   */
  pr_activity_id?: number;
  /**
   * The elapsed time ot the PR effort.
   * @type {number}
   * @memberof SummaryPRSegmentEffort
   */
  pr_elapsed_time?: number;
  /**
   * The time at which the PR effort was started.
   * @type {Date}
   * @memberof SummaryPRSegmentEffort
   */
  pr_date?: Date;
  /**
   * Number of efforts by the authenticated athlete on this segment.
   * @type {number}
   * @memberof SummaryPRSegmentEffort
   */
  effort_count?: number;
}

/**
 *
 * @export
 * @interface SummarySegment
 */
export interface SummarySegment {
  /**
   * The unique identifier of this segment
   * @type {number}
   * @memberof SummarySegment
   */
  id?: number;
  /**
   * The name of this segment
   * @type {string}
   * @memberof SummarySegment
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof SummarySegment
   */
  activity_type?: SummarySegment.ActivityTypeEnum;
  /**
   * The segment's distance, in meters
   * @type {number}
   * @memberof SummarySegment
   */
  distance?: number;
  /**
   * The segment's average grade, in percents
   * @type {number}
   * @memberof SummarySegment
   */
  average_grade?: number;
  /**
   * The segments's maximum grade, in percents
   * @type {number}
   * @memberof SummarySegment
   */
  maximum_grade?: number;
  /**
   * The segments's highest elevation, in meters
   * @type {number}
   * @memberof SummarySegment
   */
  elevation_high?: number;
  /**
   * The segments's lowest elevation, in meters
   * @type {number}
   * @memberof SummarySegment
   */
  elevation_low?: number;
  /**
   *
   * @type {LatLng}
   * @memberof SummarySegment
   */
  start_latlng?: LatLng;
  /**
   *
   * @type {LatLng}
   * @memberof SummarySegment
   */
  end_latlng?: LatLng;
  /**
   * The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catégorie, 0 is uncategorized in climb_category.
   * @type {number}
   * @memberof SummarySegment
   */
  climb_category?: number;
  /**
   * The segments's city.
   * @type {string}
   * @memberof SummarySegment
   */
  city?: string;
  /**
   * The segments's state or geographical region.
   * @type {string}
   * @memberof SummarySegment
   */
  state?: string;
  /**
   * The segment's country.
   * @type {string}
   * @memberof SummarySegment
   */
  country?: string;
  /**
   * Whether this segment is private.
   * @type {boolean}
   * @memberof SummarySegment
   */
  _private?: boolean;
  /**
   *
   * @type {SummaryPRSegmentEffort}
   * @memberof SummarySegment
   */
  athlete_pr_effort?: SummaryPRSegmentEffort;
  /**
   *
   * @type {SummarySegmentEffort}
   * @memberof SummarySegment
   */
  athlete_segment_stats?: SummarySegmentEffort;
}

/**
 * @export
 * @namespace SummarySegment
 */
export namespace SummarySegment {
  /**
   * @export
   * @enum {string}
   */
  export enum ActivityTypeEnum {
    Ride = <any>'Ride',
    Run = <any>'Run'
  }
}

/**
 *
 * @export
 * @interface SummarySegmentEffort
 */
export interface SummarySegmentEffort {
  /**
   * The unique identifier of this effort
   * @type {number}
   * @memberof SummarySegmentEffort
   */
  id?: number;
  /**
   * The unique identifier of the activity related to this effort
   * @type {number}
   * @memberof SummarySegmentEffort
   */
  activity_id?: number;
  /**
   * The effort's elapsed time
   * @type {number}
   * @memberof SummarySegmentEffort
   */
  elapsed_time?: number;
  /**
   * The time at which the effort was started.
   * @type {Date}
   * @memberof SummarySegmentEffort
   */
  start_date?: Date;
  /**
   * The time at which the effort was started in the local timezone.
   * @type {Date}
   * @memberof SummarySegmentEffort
   */
  start_date_local?: Date;
  /**
   * The effort's distance in meters
   * @type {number}
   * @memberof SummarySegmentEffort
   */
  distance?: number;
  /**
   * Whether this effort is the current best on the leaderboard
   * @type {boolean}
   * @memberof SummarySegmentEffort
   */
  is_kom?: boolean;
}

/**
 *
 * @export
 * @interface TemperatureStream
 */
export interface TemperatureStream extends BaseStream {
  /**
   * The sequence of temperature values for this stream, in celsius degrees
   * @type {Array<number>}
   * @memberof TemperatureStream
   */
  data?: Array<number>;
}

/**
 * @export
 * @namespace TemperatureStream
 */
export namespace TemperatureStream {}

/**
 *
 * @export
 * @interface TimeStream
 */
export interface TimeStream extends BaseStream {
  /**
   * The sequence of time values for this stream, in seconds
   * @type {Array<number>}
   * @memberof TimeStream
   */
  data?: Array<number>;
}

/**
 * @export
 * @namespace TimeStream
 */
export namespace TimeStream {}

/**
 * Stores the exclusive ranges representing zones and the time spent in each.
 * @export
 * @interface TimedZoneDistribution
 */
export interface TimedZoneDistribution extends Array<TimedZoneRange> {}

/**
 * A union type representing the time spent in a given zone.
 * @export
 * @interface TimedZoneRange
 */
export interface TimedZoneRange extends ZoneRange {
  /**
   * The number of seconds spent in this zone
   * @type {number}
   * @memberof TimedZoneRange
   */
  time?: number;
}

/**
 *
 * @export
 * @interface UpdatableActivity
 */
export interface UpdatableActivity {
  /**
   * Whether this activity is a commute
   * @type {boolean}
   * @memberof UpdatableActivity
   */
  commute?: boolean;
  /**
   * Whether this activity was recorded on a training machine
   * @type {boolean}
   * @memberof UpdatableActivity
   */
  trainer?: boolean;
  /**
   * Whether this activity is muted
   * @type {boolean}
   * @memberof UpdatableActivity
   */
  hide_from_home?: boolean;
  /**
   * The description of the activity
   * @type {string}
   * @memberof UpdatableActivity
   */
  description?: string;
  /**
   * The name of the activity
   * @type {string}
   * @memberof UpdatableActivity
   */
  name?: string;
  /**
   * Deprecated. Prefer to use sport_type. In a request where both type and sport_type are present, this field will be ignored
   * @type {ActivityType}
   * @memberof UpdatableActivity
   */
  type?: ActivityType;
  /**
   *
   * @type {SportType}
   * @memberof UpdatableActivity
   */
  sport_type?: SportType;
  /**
   * Identifier for the gear associated with the activity. ‘none’ clears gear from activity
   * @type {string}
   * @memberof UpdatableActivity
   */
  gear_id?: string;
}

/**
 *
 * @export
 * @interface Upload
 */
export interface Upload {
  /**
   * The unique identifier of the upload
   * @type {number}
   * @memberof Upload
   */
  id?: number;
  /**
   * The unique identifier of the upload in string format
   * @type {string}
   * @memberof Upload
   */
  id_str?: string;
  /**
   * The external identifier of the upload
   * @type {string}
   * @memberof Upload
   */
  external_id?: string;
  /**
   * The error associated with this upload
   * @type {string}
   * @memberof Upload
   */
  error?: string;
  /**
   * The status of this upload
   * @type {string}
   * @memberof Upload
   */
  status?: string;
  /**
   * The identifier of the activity this upload resulted into
   * @type {number}
   * @memberof Upload
   */
  activity_id?: number;
}

/**
 *
 * @export
 * @interface ZoneRange
 */
export interface ZoneRange {
  /**
   * The minimum value in the range.
   * @type {number}
   * @memberof ZoneRange
   */
  min?: number;
  /**
   * The maximum value in the range.
   * @type {number}
   * @memberof ZoneRange
   */
  max?: number;
}

/**
 *
 * @export
 * @interface ZoneRanges
 */
export interface ZoneRanges extends Array<ZoneRange> {}

/**
 *
 * @export
 * @interface Zones
 */
export interface Zones {
  /**
   *
   * @type {HeartRateZoneRanges}
   * @memberof Zones
   */
  heart_rate?: HeartRateZoneRanges;
  /**
   *
   * @type {PowerZoneRanges}
   * @memberof Zones
   */
  power?: PowerZoneRanges;
}

/**
 * ActivitiesApi - fetch parameter creator
 * @export
 */
export const ActivitiesApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Creates a manual activity for an athlete, requires activity:write scope.
     * @summary Create an Activity
     * @param {string} name The name of the activity.
     * @param {string} sport_type Sport type of activity. For example - Run, MountainBikeRide, Ride, etc.
     * @param {Date} start_date_local ISO 8601 formatted date time.
     * @param {number} elapsed_time In seconds.
     * @param {string} [type] Type of activity. For example - Run, Ride etc.
     * @param {string} [description] Description of the activity.
     * @param {number} [distance] In meters.
     * @param {number} [trainer] Set to 1 to mark as a trainer activity.
     * @param {number} [commute] Set to 1 to mark as commute.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createActivity(
      name: string,
      sport_type: string,
      start_date_local: Date,
      elapsed_time: number,
      type?: string,
      description?: string,
      distance?: number,
      trainer?: number,
      commute?: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          'name',
          'Required parameter name was null or undefined when calling createActivity.'
        );
      }
      // verify required parameter 'sport_type' is not null or undefined
      if (sport_type === null || sport_type === undefined) {
        throw new RequiredError(
          'sport_type',
          'Required parameter sport_type was null or undefined when calling createActivity.'
        );
      }
      // verify required parameter 'start_date_local' is not null or undefined
      if (start_date_local === null || start_date_local === undefined) {
        throw new RequiredError(
          'start_date_local',
          'Required parameter start_date_local was null or undefined when calling createActivity.'
        );
      }
      // verify required parameter 'elapsed_time' is not null or undefined
      if (elapsed_time === null || elapsed_time === undefined) {
        throw new RequiredError(
          'elapsed_time',
          'Required parameter elapsed_time was null or undefined when calling createActivity.'
        );
      }
      const localVarPath = `/activities`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new url.URLSearchParams();

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (name !== undefined) {
        localVarFormParams.set('name', name as any);
      }

      if (type !== undefined) {
        localVarFormParams.set('type', type as any);
      }

      if (sport_type !== undefined) {
        localVarFormParams.set('sport_type', sport_type as any);
      }

      if (start_date_local !== undefined) {
        localVarFormParams.set('start_date_local', start_date_local as any);
      }

      if (elapsed_time !== undefined) {
        localVarFormParams.set('elapsed_time', elapsed_time as any);
      }

      if (description !== undefined) {
        localVarFormParams.set('description', description as any);
      }

      if (distance !== undefined) {
        localVarFormParams.set('distance', distance as any);
      }

      if (trainer !== undefined) {
        localVarFormParams.set('trainer', trainer as any);
      }

      if (commute !== undefined) {
        localVarFormParams.set('commute', commute as any);
      }

      localVarHeaderParameter['Content-Type'] =
        'application/x-www-form-urlencoded';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      localVarRequestOptions.body = localVarFormParams.toString();

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the given activity that is owned by the authenticated athlete. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
     * @summary Get Activity
     * @param {number} id The identifier of the activity.
     * @param {boolean} [include_all_efforts] To include all segments efforts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivityById(
      id: number,
      include_all_efforts?: boolean,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getActivityById.'
        );
      }
      const localVarPath = `/activities/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (include_all_efforts !== undefined) {
        localVarQueryParameter['include_all_efforts'] = include_all_efforts;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the comments on the given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
     * @summary List Activity Comments
     * @param {number} id The identifier of the activity.
     * @param {number} [page] Deprecated. Prefer to use after_cursor.
     * @param {number} [per_page] Deprecated. Prefer to use page_size.
     * @param {number} [page_size] Number of items per page. Defaults to 30.
     * @param {string} [after_cursor] Cursor of the last item in the previous page of results, used to request the subsequent page of results.  When omitted, the first page of results is fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCommentsByActivityId(
      id: number,
      page?: number,
      per_page?: number,
      page_size?: number,
      after_cursor?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getCommentsByActivityId.'
        );
      }
      const localVarPath = `/activities/{id}/comments`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (per_page !== undefined) {
        localVarQueryParameter['per_page'] = per_page;
      }

      if (page_size !== undefined) {
        localVarQueryParameter['page_size'] = page_size;
      }

      if (after_cursor !== undefined) {
        localVarQueryParameter['after_cursor'] = after_cursor;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the athletes who kudoed an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
     * @summary List Activity Kudoers
     * @param {number} id The identifier of the activity.
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [per_page] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKudoersByActivityId(
      id: number,
      page?: number,
      per_page?: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getKudoersByActivityId.'
        );
      }
      const localVarPath = `/activities/{id}/kudos`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (per_page !== undefined) {
        localVarQueryParameter['per_page'] = per_page;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the laps of an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
     * @summary List Activity Laps
     * @param {number} id The identifier of the activity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLapsByActivityId(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getLapsByActivityId.'
        );
      }
      const localVarPath = `/activities/{id}/laps`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the activities of an athlete for a specific identifier. Requires activity:read. Only Me activities will be filtered out unless requested by a token with activity:read_all.
     * @summary List Athlete Activities
     * @param {number} [before] An epoch timestamp to use for filtering activities that have taken place before a certain time.
     * @param {number} [after] An epoch timestamp to use for filtering activities that have taken place after a certain time.
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [per_page] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoggedInAthleteActivities(
      before?: number,
      after?: number,
      page?: number,
      per_page?: number,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/athlete/activities`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (before !== undefined) {
        localVarQueryParameter['before'] = before;
      }

      if (after !== undefined) {
        localVarQueryParameter['after'] = after;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (per_page !== undefined) {
        localVarQueryParameter['per_page'] = per_page;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Summit Feature. Returns the zones of a given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
     * @summary Get Activity Zones
     * @param {number} id The identifier of the activity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getZonesByActivityId(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getZonesByActivityId.'
        );
      }
      const localVarPath = `/activities/{id}/zones`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Updates the given activity that is owned by the authenticated athlete. Requires activity:write. Also requires activity:read_all in order to update Only Me activities
     * @summary Update Activity
     * @param {number} id The identifier of the activity.
     * @param {UpdatableActivity} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateActivityById(
      id: number,
      body?: UpdatableActivity,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateActivityById.'
        );
      }
      const localVarPath = `/activities/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>'UpdatableActivity' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * ActivitiesApi - functional programming interface
 * @export
 */
export const ActivitiesApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Creates a manual activity for an athlete, requires activity:write scope.
     * @summary Create an Activity
     * @param {string} name The name of the activity.
     * @param {string} sport_type Sport type of activity. For example - Run, MountainBikeRide, Ride, etc.
     * @param {Date} start_date_local ISO 8601 formatted date time.
     * @param {number} elapsed_time In seconds.
     * @param {string} [type] Type of activity. For example - Run, Ride etc.
     * @param {string} [description] Description of the activity.
     * @param {number} [distance] In meters.
     * @param {number} [trainer] Set to 1 to mark as a trainer activity.
     * @param {number} [commute] Set to 1 to mark as commute.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createActivity(
      name: string,
      sport_type: string,
      start_date_local: Date,
      elapsed_time: number,
      type?: string,
      description?: string,
      distance?: number,
      trainer?: number,
      commute?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedActivity> {
      const localVarFetchArgs = ActivitiesApiFetchParamCreator(
        configuration
      ).createActivity(
        name,
        sport_type,
        start_date_local,
        elapsed_time,
        type,
        description,
        distance,
        trainer,
        commute,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns the given activity that is owned by the authenticated athlete. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
     * @summary Get Activity
     * @param {number} id The identifier of the activity.
     * @param {boolean} [include_all_efforts] To include all segments efforts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivityById(
      id: number,
      include_all_efforts?: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedActivity> {
      const localVarFetchArgs = ActivitiesApiFetchParamCreator(
        configuration
      ).getActivityById(id, include_all_efforts, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns the comments on the given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
     * @summary List Activity Comments
     * @param {number} id The identifier of the activity.
     * @param {number} [page] Deprecated. Prefer to use after_cursor.
     * @param {number} [per_page] Deprecated. Prefer to use page_size.
     * @param {number} [page_size] Number of items per page. Defaults to 30.
     * @param {string} [after_cursor] Cursor of the last item in the previous page of results, used to request the subsequent page of results.  When omitted, the first page of results is fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCommentsByActivityId(
      id: number,
      page?: number,
      per_page?: number,
      page_size?: number,
      after_cursor?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Comment>> {
      const localVarFetchArgs = ActivitiesApiFetchParamCreator(
        configuration
      ).getCommentsByActivityId(
        id,
        page,
        per_page,
        page_size,
        after_cursor,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns the athletes who kudoed an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
     * @summary List Activity Kudoers
     * @param {number} id The identifier of the activity.
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [per_page] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKudoersByActivityId(
      id: number,
      page?: number,
      per_page?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SummaryAthlete>> {
      const localVarFetchArgs = ActivitiesApiFetchParamCreator(
        configuration
      ).getKudoersByActivityId(id, page, per_page, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns the laps of an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
     * @summary List Activity Laps
     * @param {number} id The identifier of the activity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLapsByActivityId(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Lap>> {
      const localVarFetchArgs = ActivitiesApiFetchParamCreator(
        configuration
      ).getLapsByActivityId(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns the activities of an athlete for a specific identifier. Requires activity:read. Only Me activities will be filtered out unless requested by a token with activity:read_all.
     * @summary List Athlete Activities
     * @param {number} [before] An epoch timestamp to use for filtering activities that have taken place before a certain time.
     * @param {number} [after] An epoch timestamp to use for filtering activities that have taken place after a certain time.
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [per_page] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoggedInAthleteActivities(
      before?: number,
      after?: number,
      page?: number,
      per_page?: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<SummaryActivity>> {
      const localVarFetchArgs = ActivitiesApiFetchParamCreator(
        configuration
      ).getLoggedInAthleteActivities(before, after, page, per_page, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Summit Feature. Returns the zones of a given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
     * @summary Get Activity Zones
     * @param {number} id The identifier of the activity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getZonesByActivityId(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ActivityZone>> {
      const localVarFetchArgs = ActivitiesApiFetchParamCreator(
        configuration
      ).getZonesByActivityId(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Updates the given activity that is owned by the authenticated athlete. Requires activity:write. Also requires activity:read_all in order to update Only Me activities
     * @summary Update Activity
     * @param {number} id The identifier of the activity.
     * @param {UpdatableActivity} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateActivityById(
      id: number,
      body?: UpdatableActivity,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedActivity> {
      const localVarFetchArgs = ActivitiesApiFetchParamCreator(
        configuration
      ).updateActivityById(id, body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    }
  };
};

/**
 * ActivitiesApi - factory interface
 * @export
 */
export const ActivitiesApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Creates a manual activity for an athlete, requires activity:write scope.
     * @summary Create an Activity
     * @param {string} name The name of the activity.
     * @param {string} sport_type Sport type of activity. For example - Run, MountainBikeRide, Ride, etc.
     * @param {Date} start_date_local ISO 8601 formatted date time.
     * @param {number} elapsed_time In seconds.
     * @param {string} [type] Type of activity. For example - Run, Ride etc.
     * @param {string} [description] Description of the activity.
     * @param {number} [distance] In meters.
     * @param {number} [trainer] Set to 1 to mark as a trainer activity.
     * @param {number} [commute] Set to 1 to mark as commute.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createActivity(
      name: string,
      sport_type: string,
      start_date_local: Date,
      elapsed_time: number,
      type?: string,
      description?: string,
      distance?: number,
      trainer?: number,
      commute?: number,
      options?: any
    ) {
      return ActivitiesApiFp(configuration).createActivity(
        name,
        sport_type,
        start_date_local,
        elapsed_time,
        type,
        description,
        distance,
        trainer,
        commute,
        options
      )(fetch, basePath);
    },
    /**
     * Returns the given activity that is owned by the authenticated athlete. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
     * @summary Get Activity
     * @param {number} id The identifier of the activity.
     * @param {boolean} [include_all_efforts] To include all segments efforts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivityById(id: number, include_all_efforts?: boolean, options?: any) {
      return ActivitiesApiFp(configuration).getActivityById(
        id,
        include_all_efforts,
        options
      )(fetch, basePath);
    },
    /**
     * Returns the comments on the given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
     * @summary List Activity Comments
     * @param {number} id The identifier of the activity.
     * @param {number} [page] Deprecated. Prefer to use after_cursor.
     * @param {number} [per_page] Deprecated. Prefer to use page_size.
     * @param {number} [page_size] Number of items per page. Defaults to 30.
     * @param {string} [after_cursor] Cursor of the last item in the previous page of results, used to request the subsequent page of results.  When omitted, the first page of results is fetched.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCommentsByActivityId(
      id: number,
      page?: number,
      per_page?: number,
      page_size?: number,
      after_cursor?: string,
      options?: any
    ) {
      return ActivitiesApiFp(configuration).getCommentsByActivityId(
        id,
        page,
        per_page,
        page_size,
        after_cursor,
        options
      )(fetch, basePath);
    },
    /**
     * Returns the athletes who kudoed an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
     * @summary List Activity Kudoers
     * @param {number} id The identifier of the activity.
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [per_page] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKudoersByActivityId(
      id: number,
      page?: number,
      per_page?: number,
      options?: any
    ) {
      return ActivitiesApiFp(configuration).getKudoersByActivityId(
        id,
        page,
        per_page,
        options
      )(fetch, basePath);
    },
    /**
     * Returns the laps of an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
     * @summary List Activity Laps
     * @param {number} id The identifier of the activity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLapsByActivityId(id: number, options?: any) {
      return ActivitiesApiFp(configuration).getLapsByActivityId(id, options)(
        fetch,
        basePath
      );
    },
    /**
     * Returns the activities of an athlete for a specific identifier. Requires activity:read. Only Me activities will be filtered out unless requested by a token with activity:read_all.
     * @summary List Athlete Activities
     * @param {number} [before] An epoch timestamp to use for filtering activities that have taken place before a certain time.
     * @param {number} [after] An epoch timestamp to use for filtering activities that have taken place after a certain time.
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [per_page] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoggedInAthleteActivities(
      before?: number,
      after?: number,
      page?: number,
      per_page?: number,
      options?: any
    ) {
      return ActivitiesApiFp(configuration).getLoggedInAthleteActivities(
        before,
        after,
        page,
        per_page,
        options
      )(fetch, basePath);
    },
    /**
     * Summit Feature. Returns the zones of a given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
     * @summary Get Activity Zones
     * @param {number} id The identifier of the activity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getZonesByActivityId(id: number, options?: any) {
      return ActivitiesApiFp(configuration).getZonesByActivityId(id, options)(
        fetch,
        basePath
      );
    },
    /**
     * Updates the given activity that is owned by the authenticated athlete. Requires activity:write. Also requires activity:read_all in order to update Only Me activities
     * @summary Update Activity
     * @param {number} id The identifier of the activity.
     * @param {UpdatableActivity} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateActivityById(id: number, body?: UpdatableActivity, options?: any) {
      return ActivitiesApiFp(configuration).updateActivityById(
        id,
        body,
        options
      )(fetch, basePath);
    }
  };
};

/**
 * ActivitiesApi - object-oriented interface
 * @export
 * @class ActivitiesApi
 * @extends {BaseAPI}
 */
export class ActivitiesApi extends BaseAPI {
  /**
   * Creates a manual activity for an athlete, requires activity:write scope.
   * @summary Create an Activity
   * @param {string} name The name of the activity.
   * @param {string} sport_type Sport type of activity. For example - Run, MountainBikeRide, Ride, etc.
   * @param {Date} start_date_local ISO 8601 formatted date time.
   * @param {number} elapsed_time In seconds.
   * @param {string} [type] Type of activity. For example - Run, Ride etc.
   * @param {string} [description] Description of the activity.
   * @param {number} [distance] In meters.
   * @param {number} [trainer] Set to 1 to mark as a trainer activity.
   * @param {number} [commute] Set to 1 to mark as commute.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActivitiesApi
   */
  public createActivity(
    name: string,
    sport_type: string,
    start_date_local: Date,
    elapsed_time: number,
    type?: string,
    description?: string,
    distance?: number,
    trainer?: number,
    commute?: number,
    options?: any
  ) {
    return ActivitiesApiFp(this.configuration).createActivity(
      name,
      sport_type,
      start_date_local,
      elapsed_time,
      type,
      description,
      distance,
      trainer,
      commute,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns the given activity that is owned by the authenticated athlete. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
   * @summary Get Activity
   * @param {number} id The identifier of the activity.
   * @param {boolean} [include_all_efforts] To include all segments efforts.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActivitiesApi
   */
  public getActivityById(
    id: number,
    include_all_efforts?: boolean,
    options?: any
  ) {
    return ActivitiesApiFp(this.configuration).getActivityById(
      id,
      include_all_efforts,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns the comments on the given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
   * @summary List Activity Comments
   * @param {number} id The identifier of the activity.
   * @param {number} [page] Deprecated. Prefer to use after_cursor.
   * @param {number} [per_page] Deprecated. Prefer to use page_size.
   * @param {number} [page_size] Number of items per page. Defaults to 30.
   * @param {string} [after_cursor] Cursor of the last item in the previous page of results, used to request the subsequent page of results.  When omitted, the first page of results is fetched.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActivitiesApi
   */
  public getCommentsByActivityId(
    id: number,
    page?: number,
    per_page?: number,
    page_size?: number,
    after_cursor?: string,
    options?: any
  ) {
    return ActivitiesApiFp(this.configuration).getCommentsByActivityId(
      id,
      page,
      per_page,
      page_size,
      after_cursor,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns the athletes who kudoed an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
   * @summary List Activity Kudoers
   * @param {number} id The identifier of the activity.
   * @param {number} [page] Page number. Defaults to 1.
   * @param {number} [per_page] Number of items per page. Defaults to 30.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActivitiesApi
   */
  public getKudoersByActivityId(
    id: number,
    page?: number,
    per_page?: number,
    options?: any
  ) {
    return ActivitiesApiFp(this.configuration).getKudoersByActivityId(
      id,
      page,
      per_page,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns the laps of an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
   * @summary List Activity Laps
   * @param {number} id The identifier of the activity.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActivitiesApi
   */
  public getLapsByActivityId(id: number, options?: any) {
    return ActivitiesApiFp(this.configuration).getLapsByActivityId(id, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns the activities of an athlete for a specific identifier. Requires activity:read. Only Me activities will be filtered out unless requested by a token with activity:read_all.
   * @summary List Athlete Activities
   * @param {number} [before] An epoch timestamp to use for filtering activities that have taken place before a certain time.
   * @param {number} [after] An epoch timestamp to use for filtering activities that have taken place after a certain time.
   * @param {number} [page] Page number. Defaults to 1.
   * @param {number} [per_page] Number of items per page. Defaults to 30.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActivitiesApi
   */
  public getLoggedInAthleteActivities(
    before?: number,
    after?: number,
    page?: number,
    per_page?: number,
    options?: any
  ) {
    return ActivitiesApiFp(this.configuration).getLoggedInAthleteActivities(
      before,
      after,
      page,
      per_page,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Summit Feature. Returns the zones of a given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
   * @summary Get Activity Zones
   * @param {number} id The identifier of the activity.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActivitiesApi
   */
  public getZonesByActivityId(id: number, options?: any) {
    return ActivitiesApiFp(this.configuration).getZonesByActivityId(
      id,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Updates the given activity that is owned by the authenticated athlete. Requires activity:write. Also requires activity:read_all in order to update Only Me activities
   * @summary Update Activity
   * @param {number} id The identifier of the activity.
   * @param {UpdatableActivity} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ActivitiesApi
   */
  public updateActivityById(
    id: number,
    body?: UpdatableActivity,
    options?: any
  ) {
    return ActivitiesApiFp(this.configuration).updateActivityById(
      id,
      body,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * AthletesApi - fetch parameter creator
 * @export
 */
export const AthletesApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns the currently authenticated athlete. Tokens with profile:read_all scope will receive a detailed athlete representation; all others will receive a summary representation.
     * @summary Get Authenticated Athlete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoggedInAthlete(options: any = {}): FetchArgs {
      const localVarPath = `/athlete`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the the authenticated athlete's heart rate and power zones. Requires profile:read_all.
     * @summary Get Zones
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoggedInAthleteZones(options: any = {}): FetchArgs {
      const localVarPath = `/athlete/zones`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the activity stats of an athlete. Only includes data from activities set to Everyone visibilty.
     * @summary Get Athlete Stats
     * @param {number} id The identifier of the athlete. Must match the authenticated athlete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStats(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getStats.'
        );
      }
      const localVarPath = `/athletes/{id}/stats`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Update the currently authenticated athlete. Requires profile:write scope.
     * @summary Update Athlete
     * @param {number} weight The weight of the athlete in kilograms.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLoggedInAthlete(weight: number, options: any = {}): FetchArgs {
      // verify required parameter 'weight' is not null or undefined
      if (weight === null || weight === undefined) {
        throw new RequiredError(
          'weight',
          'Required parameter weight was null or undefined when calling updateLoggedInAthlete.'
        );
      }
      const localVarPath = `/athlete`.replace(
        `{${'weight'}}`,
        encodeURIComponent(String(weight))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * AthletesApi - functional programming interface
 * @export
 */
export const AthletesApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Returns the currently authenticated athlete. Tokens with profile:read_all scope will receive a detailed athlete representation; all others will receive a summary representation.
     * @summary Get Authenticated Athlete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoggedInAthlete(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedAthlete> {
      const localVarFetchArgs =
        AthletesApiFetchParamCreator(configuration).getLoggedInAthlete(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns the the authenticated athlete's heart rate and power zones. Requires profile:read_all.
     * @summary Get Zones
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoggedInAthleteZones(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Zones> {
      const localVarFetchArgs =
        AthletesApiFetchParamCreator(configuration).getLoggedInAthleteZones(
          options
        );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns the activity stats of an athlete. Only includes data from activities set to Everyone visibilty.
     * @summary Get Athlete Stats
     * @param {number} id The identifier of the athlete. Must match the authenticated athlete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStats(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ActivityStats> {
      const localVarFetchArgs = AthletesApiFetchParamCreator(
        configuration
      ).getStats(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Update the currently authenticated athlete. Requires profile:write scope.
     * @summary Update Athlete
     * @param {number} weight The weight of the athlete in kilograms.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLoggedInAthlete(
      weight: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedAthlete> {
      const localVarFetchArgs = AthletesApiFetchParamCreator(
        configuration
      ).updateLoggedInAthlete(weight, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    }
  };
};

/**
 * AthletesApi - factory interface
 * @export
 */
export const AthletesApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Returns the currently authenticated athlete. Tokens with profile:read_all scope will receive a detailed athlete representation; all others will receive a summary representation.
     * @summary Get Authenticated Athlete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoggedInAthlete(options?: any) {
      return AthletesApiFp(configuration).getLoggedInAthlete(options)(
        fetch,
        basePath
      );
    },
    /**
     * Returns the the authenticated athlete's heart rate and power zones. Requires profile:read_all.
     * @summary Get Zones
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoggedInAthleteZones(options?: any) {
      return AthletesApiFp(configuration).getLoggedInAthleteZones(options)(
        fetch,
        basePath
      );
    },
    /**
     * Returns the activity stats of an athlete. Only includes data from activities set to Everyone visibilty.
     * @summary Get Athlete Stats
     * @param {number} id The identifier of the athlete. Must match the authenticated athlete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStats(id: number, options?: any) {
      return AthletesApiFp(configuration).getStats(id, options)(
        fetch,
        basePath
      );
    },
    /**
     * Update the currently authenticated athlete. Requires profile:write scope.
     * @summary Update Athlete
     * @param {number} weight The weight of the athlete in kilograms.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLoggedInAthlete(weight: number, options?: any) {
      return AthletesApiFp(configuration).updateLoggedInAthlete(
        weight,
        options
      )(fetch, basePath);
    }
  };
};

/**
 * AthletesApi - object-oriented interface
 * @export
 * @class AthletesApi
 * @extends {BaseAPI}
 */
export class AthletesApi extends BaseAPI {
  /**
   * Returns the currently authenticated athlete. Tokens with profile:read_all scope will receive a detailed athlete representation; all others will receive a summary representation.
   * @summary Get Authenticated Athlete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AthletesApi
   */
  public getLoggedInAthlete(options?: any) {
    return AthletesApiFp(this.configuration).getLoggedInAthlete(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns the the authenticated athlete's heart rate and power zones. Requires profile:read_all.
   * @summary Get Zones
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AthletesApi
   */
  public getLoggedInAthleteZones(options?: any) {
    return AthletesApiFp(this.configuration).getLoggedInAthleteZones(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns the activity stats of an athlete. Only includes data from activities set to Everyone visibilty.
   * @summary Get Athlete Stats
   * @param {number} id The identifier of the athlete. Must match the authenticated athlete.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AthletesApi
   */
  public getStats(id: number, options?: any) {
    return AthletesApiFp(this.configuration).getStats(id, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Update the currently authenticated athlete. Requires profile:write scope.
   * @summary Update Athlete
   * @param {number} weight The weight of the athlete in kilograms.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AthletesApi
   */
  public updateLoggedInAthlete(weight: number, options?: any) {
    return AthletesApiFp(this.configuration).updateLoggedInAthlete(
      weight,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * ClubsApi - fetch parameter creator
 * @export
 */
export const ClubsApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Retrieve recent activities from members of a specific club. The authenticated athlete must belong to the requested club in order to hit this endpoint. Pagination is supported. Athlete profile visibility is respected for all activities.
     * @summary List Club Activities
     * @param {number} id The identifier of the club.
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [per_page] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClubActivitiesById(
      id: number,
      page?: number,
      per_page?: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getClubActivitiesById.'
        );
      }
      const localVarPath = `/clubs/{id}/activities`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (per_page !== undefined) {
        localVarQueryParameter['per_page'] = per_page;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a list of the administrators of a given club.
     * @summary List Club Administrators
     * @param {number} id The identifier of the club.
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [per_page] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClubAdminsById(
      id: number,
      page?: number,
      per_page?: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getClubAdminsById.'
        );
      }
      const localVarPath = `/clubs/{id}/admins`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (per_page !== undefined) {
        localVarQueryParameter['per_page'] = per_page;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a given club using its identifier.
     * @summary Get Club
     * @param {number} id The identifier of the club.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClubById(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getClubById.'
        );
      }
      const localVarPath = `/clubs/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a list of the athletes who are members of a given club.
     * @summary List Club Members
     * @param {number} id The identifier of the club.
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [per_page] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClubMembersById(
      id: number,
      page?: number,
      per_page?: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getClubMembersById.'
        );
      }
      const localVarPath = `/clubs/{id}/members`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (per_page !== undefined) {
        localVarQueryParameter['per_page'] = per_page;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a list of the clubs whose membership includes the authenticated athlete.
     * @summary List Athlete Clubs
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [per_page] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoggedInAthleteClubs(
      page?: number,
      per_page?: number,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/athlete/clubs`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (per_page !== undefined) {
        localVarQueryParameter['per_page'] = per_page;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * ClubsApi - functional programming interface
 * @export
 */
export const ClubsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Retrieve recent activities from members of a specific club. The authenticated athlete must belong to the requested club in order to hit this endpoint. Pagination is supported. Athlete profile visibility is respected for all activities.
     * @summary List Club Activities
     * @param {number} id The identifier of the club.
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [per_page] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClubActivitiesById(
      id: number,
      page?: number,
      per_page?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ClubActivity>> {
      const localVarFetchArgs = ClubsApiFetchParamCreator(
        configuration
      ).getClubActivitiesById(id, page, per_page, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of the administrators of a given club.
     * @summary List Club Administrators
     * @param {number} id The identifier of the club.
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [per_page] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClubAdminsById(
      id: number,
      page?: number,
      per_page?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SummaryAthlete>> {
      const localVarFetchArgs = ClubsApiFetchParamCreator(
        configuration
      ).getClubAdminsById(id, page, per_page, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a given club using its identifier.
     * @summary Get Club
     * @param {number} id The identifier of the club.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClubById(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedClub> {
      const localVarFetchArgs = ClubsApiFetchParamCreator(
        configuration
      ).getClubById(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of the athletes who are members of a given club.
     * @summary List Club Members
     * @param {number} id The identifier of the club.
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [per_page] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClubMembersById(
      id: number,
      page?: number,
      per_page?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ClubAthlete>> {
      const localVarFetchArgs = ClubsApiFetchParamCreator(
        configuration
      ).getClubMembersById(id, page, per_page, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of the clubs whose membership includes the authenticated athlete.
     * @summary List Athlete Clubs
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [per_page] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoggedInAthleteClubs(
      page?: number,
      per_page?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SummaryClub>> {
      const localVarFetchArgs = ClubsApiFetchParamCreator(
        configuration
      ).getLoggedInAthleteClubs(page, per_page, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    }
  };
};

/**
 * ClubsApi - factory interface
 * @export
 */
export const ClubsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Retrieve recent activities from members of a specific club. The authenticated athlete must belong to the requested club in order to hit this endpoint. Pagination is supported. Athlete profile visibility is respected for all activities.
     * @summary List Club Activities
     * @param {number} id The identifier of the club.
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [per_page] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClubActivitiesById(
      id: number,
      page?: number,
      per_page?: number,
      options?: any
    ) {
      return ClubsApiFp(configuration).getClubActivitiesById(
        id,
        page,
        per_page,
        options
      )(fetch, basePath);
    },
    /**
     * Returns a list of the administrators of a given club.
     * @summary List Club Administrators
     * @param {number} id The identifier of the club.
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [per_page] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClubAdminsById(
      id: number,
      page?: number,
      per_page?: number,
      options?: any
    ) {
      return ClubsApiFp(configuration).getClubAdminsById(
        id,
        page,
        per_page,
        options
      )(fetch, basePath);
    },
    /**
     * Returns a given club using its identifier.
     * @summary Get Club
     * @param {number} id The identifier of the club.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClubById(id: number, options?: any) {
      return ClubsApiFp(configuration).getClubById(id, options)(
        fetch,
        basePath
      );
    },
    /**
     * Returns a list of the athletes who are members of a given club.
     * @summary List Club Members
     * @param {number} id The identifier of the club.
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [per_page] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClubMembersById(
      id: number,
      page?: number,
      per_page?: number,
      options?: any
    ) {
      return ClubsApiFp(configuration).getClubMembersById(
        id,
        page,
        per_page,
        options
      )(fetch, basePath);
    },
    /**
     * Returns a list of the clubs whose membership includes the authenticated athlete.
     * @summary List Athlete Clubs
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [per_page] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoggedInAthleteClubs(page?: number, per_page?: number, options?: any) {
      return ClubsApiFp(configuration).getLoggedInAthleteClubs(
        page,
        per_page,
        options
      )(fetch, basePath);
    }
  };
};

/**
 * ClubsApi - object-oriented interface
 * @export
 * @class ClubsApi
 * @extends {BaseAPI}
 */
export class ClubsApi extends BaseAPI {
  /**
   * Retrieve recent activities from members of a specific club. The authenticated athlete must belong to the requested club in order to hit this endpoint. Pagination is supported. Athlete profile visibility is respected for all activities.
   * @summary List Club Activities
   * @param {number} id The identifier of the club.
   * @param {number} [page] Page number. Defaults to 1.
   * @param {number} [per_page] Number of items per page. Defaults to 30.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClubsApi
   */
  public getClubActivitiesById(
    id: number,
    page?: number,
    per_page?: number,
    options?: any
  ) {
    return ClubsApiFp(this.configuration).getClubActivitiesById(
      id,
      page,
      per_page,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns a list of the administrators of a given club.
   * @summary List Club Administrators
   * @param {number} id The identifier of the club.
   * @param {number} [page] Page number. Defaults to 1.
   * @param {number} [per_page] Number of items per page. Defaults to 30.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClubsApi
   */
  public getClubAdminsById(
    id: number,
    page?: number,
    per_page?: number,
    options?: any
  ) {
    return ClubsApiFp(this.configuration).getClubAdminsById(
      id,
      page,
      per_page,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns a given club using its identifier.
   * @summary Get Club
   * @param {number} id The identifier of the club.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClubsApi
   */
  public getClubById(id: number, options?: any) {
    return ClubsApiFp(this.configuration).getClubById(id, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns a list of the athletes who are members of a given club.
   * @summary List Club Members
   * @param {number} id The identifier of the club.
   * @param {number} [page] Page number. Defaults to 1.
   * @param {number} [per_page] Number of items per page. Defaults to 30.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClubsApi
   */
  public getClubMembersById(
    id: number,
    page?: number,
    per_page?: number,
    options?: any
  ) {
    return ClubsApiFp(this.configuration).getClubMembersById(
      id,
      page,
      per_page,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns a list of the clubs whose membership includes the authenticated athlete.
   * @summary List Athlete Clubs
   * @param {number} [page] Page number. Defaults to 1.
   * @param {number} [per_page] Number of items per page. Defaults to 30.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClubsApi
   */
  public getLoggedInAthleteClubs(
    page?: number,
    per_page?: number,
    options?: any
  ) {
    return ClubsApiFp(this.configuration).getLoggedInAthleteClubs(
      page,
      per_page,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * GearsApi - fetch parameter creator
 * @export
 */
export const GearsApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns an equipment using its identifier.
     * @summary Get Equipment
     * @param {string} id The identifier of the gear.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGearById(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getGearById.'
        );
      }
      const localVarPath = `/gear/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * GearsApi - functional programming interface
 * @export
 */
export const GearsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Returns an equipment using its identifier.
     * @summary Get Equipment
     * @param {string} id The identifier of the gear.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGearById(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedGear> {
      const localVarFetchArgs = GearsApiFetchParamCreator(
        configuration
      ).getGearById(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    }
  };
};

/**
 * GearsApi - factory interface
 * @export
 */
export const GearsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Returns an equipment using its identifier.
     * @summary Get Equipment
     * @param {string} id The identifier of the gear.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGearById(id: string, options?: any) {
      return GearsApiFp(configuration).getGearById(id, options)(
        fetch,
        basePath
      );
    }
  };
};

/**
 * GearsApi - object-oriented interface
 * @export
 * @class GearsApi
 * @extends {BaseAPI}
 */
export class GearsApi extends BaseAPI {
  /**
   * Returns an equipment using its identifier.
   * @summary Get Equipment
   * @param {string} id The identifier of the gear.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GearsApi
   */
  public getGearById(id: string, options?: any) {
    return GearsApiFp(this.configuration).getGearById(id, options)(
      this.fetch,
      this.basePath
    );
  }
}

/**
 * RoutesApi - fetch parameter creator
 * @export
 */
export const RoutesApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns a GPX file of the route. Requires read_all scope for private routes.
     * @summary Export Route GPX
     * @param {number} id The identifier of the route.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRouteAsGPX(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getRouteAsGPX.'
        );
      }
      const localVarPath = `/routes/{id}/export_gpx`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a TCX file of the route. Requires read_all scope for private routes.
     * @summary Export Route TCX
     * @param {number} id The identifier of the route.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRouteAsTCX(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getRouteAsTCX.'
        );
      }
      const localVarPath = `/routes/{id}/export_tcx`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a route using its identifier. Requires read_all scope for private routes.
     * @summary Get Route
     * @param {number} id The identifier of the route.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRouteById(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getRouteById.'
        );
      }
      const localVarPath = `/routes/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a list of the routes created by the authenticated athlete. Private routes are filtered out unless requested by a token with read_all scope.
     * @summary List Athlete Routes
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [per_page] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoutesByAthleteId(
      page?: number,
      per_page?: number,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/athletes/{id}/routes`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (per_page !== undefined) {
        localVarQueryParameter['per_page'] = per_page;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * RoutesApi - functional programming interface
 * @export
 */
export const RoutesApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Returns a GPX file of the route. Requires read_all scope for private routes.
     * @summary Export Route GPX
     * @param {number} id The identifier of the route.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRouteAsGPX(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = RoutesApiFetchParamCreator(
        configuration
      ).getRouteAsGPX(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a TCX file of the route. Requires read_all scope for private routes.
     * @summary Export Route TCX
     * @param {number} id The identifier of the route.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRouteAsTCX(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = RoutesApiFetchParamCreator(
        configuration
      ).getRouteAsTCX(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a route using its identifier. Requires read_all scope for private routes.
     * @summary Get Route
     * @param {number} id The identifier of the route.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRouteById(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Route> {
      const localVarFetchArgs = RoutesApiFetchParamCreator(
        configuration
      ).getRouteById(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of the routes created by the authenticated athlete. Private routes are filtered out unless requested by a token with read_all scope.
     * @summary List Athlete Routes
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [per_page] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoutesByAthleteId(
      page?: number,
      per_page?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Route>> {
      const localVarFetchArgs = RoutesApiFetchParamCreator(
        configuration
      ).getRoutesByAthleteId(page, per_page, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    }
  };
};

/**
 * RoutesApi - factory interface
 * @export
 */
export const RoutesApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Returns a GPX file of the route. Requires read_all scope for private routes.
     * @summary Export Route GPX
     * @param {number} id The identifier of the route.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRouteAsGPX(id: number, options?: any) {
      return RoutesApiFp(configuration).getRouteAsGPX(id, options)(
        fetch,
        basePath
      );
    },
    /**
     * Returns a TCX file of the route. Requires read_all scope for private routes.
     * @summary Export Route TCX
     * @param {number} id The identifier of the route.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRouteAsTCX(id: number, options?: any) {
      return RoutesApiFp(configuration).getRouteAsTCX(id, options)(
        fetch,
        basePath
      );
    },
    /**
     * Returns a route using its identifier. Requires read_all scope for private routes.
     * @summary Get Route
     * @param {number} id The identifier of the route.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRouteById(id: number, options?: any) {
      return RoutesApiFp(configuration).getRouteById(id, options)(
        fetch,
        basePath
      );
    },
    /**
     * Returns a list of the routes created by the authenticated athlete. Private routes are filtered out unless requested by a token with read_all scope.
     * @summary List Athlete Routes
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [per_page] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoutesByAthleteId(page?: number, per_page?: number, options?: any) {
      return RoutesApiFp(configuration).getRoutesByAthleteId(
        page,
        per_page,
        options
      )(fetch, basePath);
    }
  };
};

/**
 * RoutesApi - object-oriented interface
 * @export
 * @class RoutesApi
 * @extends {BaseAPI}
 */
export class RoutesApi extends BaseAPI {
  /**
   * Returns a GPX file of the route. Requires read_all scope for private routes.
   * @summary Export Route GPX
   * @param {number} id The identifier of the route.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoutesApi
   */
  public getRouteAsGPX(id: number, options?: any) {
    return RoutesApiFp(this.configuration).getRouteAsGPX(id, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns a TCX file of the route. Requires read_all scope for private routes.
   * @summary Export Route TCX
   * @param {number} id The identifier of the route.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoutesApi
   */
  public getRouteAsTCX(id: number, options?: any) {
    return RoutesApiFp(this.configuration).getRouteAsTCX(id, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns a route using its identifier. Requires read_all scope for private routes.
   * @summary Get Route
   * @param {number} id The identifier of the route.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoutesApi
   */
  public getRouteById(id: number, options?: any) {
    return RoutesApiFp(this.configuration).getRouteById(id, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns a list of the routes created by the authenticated athlete. Private routes are filtered out unless requested by a token with read_all scope.
   * @summary List Athlete Routes
   * @param {number} [page] Page number. Defaults to 1.
   * @param {number} [per_page] Number of items per page. Defaults to 30.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoutesApi
   */
  public getRoutesByAthleteId(page?: number, per_page?: number, options?: any) {
    return RoutesApiFp(this.configuration).getRoutesByAthleteId(
      page,
      per_page,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * SegmentEffortsApi - fetch parameter creator
 * @export
 */
export const SegmentEffortsApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns a set of the authenticated athlete's segment efforts for a given segment.  Requires subscription.
     * @summary List Segment Efforts
     * @param {number} segment_id The identifier of the segment.
     * @param {Date} [start_date_local] ISO 8601 formatted date time.
     * @param {Date} [end_date_local] ISO 8601 formatted date time.
     * @param {number} [per_page] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEffortsBySegmentId(
      segment_id: number,
      start_date_local?: Date,
      end_date_local?: Date,
      per_page?: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'segment_id' is not null or undefined
      if (segment_id === null || segment_id === undefined) {
        throw new RequiredError(
          'segment_id',
          'Required parameter segment_id was null or undefined when calling getEffortsBySegmentId.'
        );
      }
      const localVarPath = `/segment_efforts`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (segment_id !== undefined) {
        localVarQueryParameter['segment_id'] = segment_id;
      }

      if (start_date_local !== undefined) {
        localVarQueryParameter['start_date_local'] = (
          start_date_local as any
        ).toISOString();
      }

      if (end_date_local !== undefined) {
        localVarQueryParameter['end_date_local'] = (
          end_date_local as any
        ).toISOString();
      }

      if (per_page !== undefined) {
        localVarQueryParameter['per_page'] = per_page;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a segment effort from an activity that is owned by the authenticated athlete. Requires subscription.
     * @summary Get Segment Effort
     * @param {number} id The identifier of the segment effort.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSegmentEffortById(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getSegmentEffortById.'
        );
      }
      const localVarPath = `/segment_efforts/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * SegmentEffortsApi - functional programming interface
 * @export
 */
export const SegmentEffortsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Returns a set of the authenticated athlete's segment efforts for a given segment.  Requires subscription.
     * @summary List Segment Efforts
     * @param {number} segment_id The identifier of the segment.
     * @param {Date} [start_date_local] ISO 8601 formatted date time.
     * @param {Date} [end_date_local] ISO 8601 formatted date time.
     * @param {number} [per_page] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEffortsBySegmentId(
      segment_id: number,
      start_date_local?: Date,
      end_date_local?: Date,
      per_page?: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<DetailedSegmentEffort>> {
      const localVarFetchArgs = SegmentEffortsApiFetchParamCreator(
        configuration
      ).getEffortsBySegmentId(
        segment_id,
        start_date_local,
        end_date_local,
        per_page,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a segment effort from an activity that is owned by the authenticated athlete. Requires subscription.
     * @summary Get Segment Effort
     * @param {number} id The identifier of the segment effort.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSegmentEffortById(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedSegmentEffort> {
      const localVarFetchArgs = SegmentEffortsApiFetchParamCreator(
        configuration
      ).getSegmentEffortById(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    }
  };
};

/**
 * SegmentEffortsApi - factory interface
 * @export
 */
export const SegmentEffortsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Returns a set of the authenticated athlete's segment efforts for a given segment.  Requires subscription.
     * @summary List Segment Efforts
     * @param {number} segment_id The identifier of the segment.
     * @param {Date} [start_date_local] ISO 8601 formatted date time.
     * @param {Date} [end_date_local] ISO 8601 formatted date time.
     * @param {number} [per_page] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEffortsBySegmentId(
      segment_id: number,
      start_date_local?: Date,
      end_date_local?: Date,
      per_page?: number,
      options?: any
    ) {
      return SegmentEffortsApiFp(configuration).getEffortsBySegmentId(
        segment_id,
        start_date_local,
        end_date_local,
        per_page,
        options
      )(fetch, basePath);
    },
    /**
     * Returns a segment effort from an activity that is owned by the authenticated athlete. Requires subscription.
     * @summary Get Segment Effort
     * @param {number} id The identifier of the segment effort.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSegmentEffortById(id: number, options?: any) {
      return SegmentEffortsApiFp(configuration).getSegmentEffortById(
        id,
        options
      )(fetch, basePath);
    }
  };
};

/**
 * SegmentEffortsApi - object-oriented interface
 * @export
 * @class SegmentEffortsApi
 * @extends {BaseAPI}
 */
export class SegmentEffortsApi extends BaseAPI {
  /**
   * Returns a set of the authenticated athlete's segment efforts for a given segment.  Requires subscription.
   * @summary List Segment Efforts
   * @param {number} segment_id The identifier of the segment.
   * @param {Date} [start_date_local] ISO 8601 formatted date time.
   * @param {Date} [end_date_local] ISO 8601 formatted date time.
   * @param {number} [per_page] Number of items per page. Defaults to 30.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SegmentEffortsApi
   */
  public getEffortsBySegmentId(
    segment_id: number,
    start_date_local?: Date,
    end_date_local?: Date,
    per_page?: number,
    options?: any
  ) {
    return SegmentEffortsApiFp(this.configuration).getEffortsBySegmentId(
      segment_id,
      start_date_local,
      end_date_local,
      per_page,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns a segment effort from an activity that is owned by the authenticated athlete. Requires subscription.
   * @summary Get Segment Effort
   * @param {number} id The identifier of the segment effort.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SegmentEffortsApi
   */
  public getSegmentEffortById(id: number, options?: any) {
    return SegmentEffortsApiFp(this.configuration).getSegmentEffortById(
      id,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * SegmentsApi - fetch parameter creator
 * @export
 */
export const SegmentsApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns the top 10 segments matching a specified query.
     * @summary Explore segments
     * @param {Array<number>} bounds The latitude and longitude for two points describing a rectangular boundary for the search: [southwest corner latitutde, southwest corner longitude, northeast corner latitude, northeast corner longitude]
     * @param {'running' | 'riding'} [activity_type] Desired activity type.
     * @param {number} [min_cat] The minimum climbing category.
     * @param {number} [max_cat] The maximum climbing category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exploreSegments(
      bounds: Array<number>,
      activity_type?: 'running' | 'riding',
      min_cat?: number,
      max_cat?: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'bounds' is not null or undefined
      if (bounds === null || bounds === undefined) {
        throw new RequiredError(
          'bounds',
          'Required parameter bounds was null or undefined when calling exploreSegments.'
        );
      }
      const localVarPath = `/segments/explore`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (bounds) {
        localVarQueryParameter['bounds'] = bounds.join(
          COLLECTION_FORMATS['csv']
        );
      }

      if (activity_type !== undefined) {
        localVarQueryParameter['activity_type'] = activity_type;
      }

      if (min_cat !== undefined) {
        localVarQueryParameter['min_cat'] = min_cat;
      }

      if (max_cat !== undefined) {
        localVarQueryParameter['max_cat'] = max_cat;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * List of the authenticated athlete's starred segments. Private segments are filtered out unless requested by a token with read_all scope.
     * @summary List Starred Segments
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [per_page] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoggedInAthleteStarredSegments(
      page?: number,
      per_page?: number,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/segments/starred`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (per_page !== undefined) {
        localVarQueryParameter['per_page'] = per_page;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the specified segment. read_all scope required in order to retrieve athlete-specific segment information, or to retrieve private segments.
     * @summary Get Segment
     * @param {number} id The identifier of the segment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSegmentById(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getSegmentById.'
        );
      }
      const localVarPath = `/segments/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Stars/Unstars the given segment for the authenticated athlete. Requires profile:write scope.
     * @summary Star Segment
     * @param {number} id The identifier of the segment to star.
     * @param {boolean} starred If true, star the segment; if false, unstar the segment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    starSegment(id: number, starred: boolean, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling starSegment.'
        );
      }
      // verify required parameter 'starred' is not null or undefined
      if (starred === null || starred === undefined) {
        throw new RequiredError(
          'starred',
          'Required parameter starred was null or undefined when calling starSegment.'
        );
      }
      const localVarPath = `/segments/{id}/starred`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new url.URLSearchParams();

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (starred !== undefined) {
        localVarFormParams.set('starred', starred as any);
      }

      localVarHeaderParameter['Content-Type'] =
        'application/x-www-form-urlencoded';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      localVarRequestOptions.body = localVarFormParams.toString();

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * SegmentsApi - functional programming interface
 * @export
 */
export const SegmentsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Returns the top 10 segments matching a specified query.
     * @summary Explore segments
     * @param {Array<number>} bounds The latitude and longitude for two points describing a rectangular boundary for the search: [southwest corner latitutde, southwest corner longitude, northeast corner latitude, northeast corner longitude]
     * @param {'running' | 'riding'} [activity_type] Desired activity type.
     * @param {number} [min_cat] The minimum climbing category.
     * @param {number} [max_cat] The maximum climbing category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exploreSegments(
      bounds: Array<number>,
      activity_type?: 'running' | 'riding',
      min_cat?: number,
      max_cat?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ExplorerResponse> {
      const localVarFetchArgs = SegmentsApiFetchParamCreator(
        configuration
      ).exploreSegments(bounds, activity_type, min_cat, max_cat, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * List of the authenticated athlete's starred segments. Private segments are filtered out unless requested by a token with read_all scope.
     * @summary List Starred Segments
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [per_page] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoggedInAthleteStarredSegments(
      page?: number,
      per_page?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SummarySegment>> {
      const localVarFetchArgs = SegmentsApiFetchParamCreator(
        configuration
      ).getLoggedInAthleteStarredSegments(page, per_page, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns the specified segment. read_all scope required in order to retrieve athlete-specific segment information, or to retrieve private segments.
     * @summary Get Segment
     * @param {number} id The identifier of the segment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSegmentById(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedSegment> {
      const localVarFetchArgs = SegmentsApiFetchParamCreator(
        configuration
      ).getSegmentById(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Stars/Unstars the given segment for the authenticated athlete. Requires profile:write scope.
     * @summary Star Segment
     * @param {number} id The identifier of the segment to star.
     * @param {boolean} starred If true, star the segment; if false, unstar the segment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    starSegment(
      id: number,
      starred: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<DetailedSegment> {
      const localVarFetchArgs = SegmentsApiFetchParamCreator(
        configuration
      ).starSegment(id, starred, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    }
  };
};

/**
 * SegmentsApi - factory interface
 * @export
 */
export const SegmentsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Returns the top 10 segments matching a specified query.
     * @summary Explore segments
     * @param {Array<number>} bounds The latitude and longitude for two points describing a rectangular boundary for the search: [southwest corner latitutde, southwest corner longitude, northeast corner latitude, northeast corner longitude]
     * @param {'running' | 'riding'} [activity_type] Desired activity type.
     * @param {number} [min_cat] The minimum climbing category.
     * @param {number} [max_cat] The maximum climbing category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exploreSegments(
      bounds: Array<number>,
      activity_type?: 'running' | 'riding',
      min_cat?: number,
      max_cat?: number,
      options?: any
    ) {
      return SegmentsApiFp(configuration).exploreSegments(
        bounds,
        activity_type,
        min_cat,
        max_cat,
        options
      )(fetch, basePath);
    },
    /**
     * List of the authenticated athlete's starred segments. Private segments are filtered out unless requested by a token with read_all scope.
     * @summary List Starred Segments
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [per_page] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoggedInAthleteStarredSegments(
      page?: number,
      per_page?: number,
      options?: any
    ) {
      return SegmentsApiFp(configuration).getLoggedInAthleteStarredSegments(
        page,
        per_page,
        options
      )(fetch, basePath);
    },
    /**
     * Returns the specified segment. read_all scope required in order to retrieve athlete-specific segment information, or to retrieve private segments.
     * @summary Get Segment
     * @param {number} id The identifier of the segment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSegmentById(id: number, options?: any) {
      return SegmentsApiFp(configuration).getSegmentById(id, options)(
        fetch,
        basePath
      );
    },
    /**
     * Stars/Unstars the given segment for the authenticated athlete. Requires profile:write scope.
     * @summary Star Segment
     * @param {number} id The identifier of the segment to star.
     * @param {boolean} starred If true, star the segment; if false, unstar the segment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    starSegment(id: number, starred: boolean, options?: any) {
      return SegmentsApiFp(configuration).starSegment(
        id,
        starred,
        options
      )(fetch, basePath);
    }
  };
};

/**
 * SegmentsApi - object-oriented interface
 * @export
 * @class SegmentsApi
 * @extends {BaseAPI}
 */
export class SegmentsApi extends BaseAPI {
  /**
   * Returns the top 10 segments matching a specified query.
   * @summary Explore segments
   * @param {Array<number>} bounds The latitude and longitude for two points describing a rectangular boundary for the search: [southwest corner latitutde, southwest corner longitude, northeast corner latitude, northeast corner longitude]
   * @param {'running' | 'riding'} [activity_type] Desired activity type.
   * @param {number} [min_cat] The minimum climbing category.
   * @param {number} [max_cat] The maximum climbing category.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SegmentsApi
   */
  public exploreSegments(
    bounds: Array<number>,
    activity_type?: 'running' | 'riding',
    min_cat?: number,
    max_cat?: number,
    options?: any
  ) {
    return SegmentsApiFp(this.configuration).exploreSegments(
      bounds,
      activity_type,
      min_cat,
      max_cat,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * List of the authenticated athlete's starred segments. Private segments are filtered out unless requested by a token with read_all scope.
   * @summary List Starred Segments
   * @param {number} [page] Page number. Defaults to 1.
   * @param {number} [per_page] Number of items per page. Defaults to 30.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SegmentsApi
   */
  public getLoggedInAthleteStarredSegments(
    page?: number,
    per_page?: number,
    options?: any
  ) {
    return SegmentsApiFp(this.configuration).getLoggedInAthleteStarredSegments(
      page,
      per_page,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns the specified segment. read_all scope required in order to retrieve athlete-specific segment information, or to retrieve private segments.
   * @summary Get Segment
   * @param {number} id The identifier of the segment.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SegmentsApi
   */
  public getSegmentById(id: number, options?: any) {
    return SegmentsApiFp(this.configuration).getSegmentById(id, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Stars/Unstars the given segment for the authenticated athlete. Requires profile:write scope.
   * @summary Star Segment
   * @param {number} id The identifier of the segment to star.
   * @param {boolean} starred If true, star the segment; if false, unstar the segment.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SegmentsApi
   */
  public starSegment(id: number, starred: boolean, options?: any) {
    return SegmentsApiFp(this.configuration).starSegment(
      id,
      starred,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * StreamsApi - fetch parameter creator
 * @export
 */
export const StreamsApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns the given activity's streams. Requires activity:read scope. Requires activity:read_all scope for Only Me activities.
     * @summary Get Activity Streams
     * @param {number} id The identifier of the activity.
     * @param {Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>} keys Desired stream types.
     * @param {boolean} key_by_type Must be true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivityStreams(
      id: number,
      keys: Array<
        | 'time'
        | 'distance'
        | 'latlng'
        | 'altitude'
        | 'velocity_smooth'
        | 'heartrate'
        | 'cadence'
        | 'watts'
        | 'temp'
        | 'moving'
        | 'grade_smooth'
      >,
      key_by_type: boolean,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getActivityStreams.'
        );
      }
      // verify required parameter 'keys' is not null or undefined
      if (keys === null || keys === undefined) {
        throw new RequiredError(
          'keys',
          'Required parameter keys was null or undefined when calling getActivityStreams.'
        );
      }
      // verify required parameter 'key_by_type' is not null or undefined
      if (key_by_type === null || key_by_type === undefined) {
        throw new RequiredError(
          'key_by_type',
          'Required parameter key_by_type was null or undefined when calling getActivityStreams.'
        );
      }
      const localVarPath = `/activities/{id}/streams`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (keys) {
        localVarQueryParameter['keys'] = keys.join(COLLECTION_FORMATS['csv']);
      }

      if (key_by_type !== undefined) {
        localVarQueryParameter['key_by_type'] = key_by_type;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the given route's streams. Requires read_all scope for private routes.
     * @summary Get Route Streams
     * @param {number} id The identifier of the route.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRouteStreams(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getRouteStreams.'
        );
      }
      const localVarPath = `/routes/{id}/streams`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns a set of streams for a segment effort completed by the authenticated athlete. Requires read_all scope.
     * @summary Get Segment Effort Streams
     * @param {number} id The identifier of the segment effort.
     * @param {Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>} keys The types of streams to return.
     * @param {boolean} key_by_type Must be true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSegmentEffortStreams(
      id: number,
      keys: Array<
        | 'time'
        | 'distance'
        | 'latlng'
        | 'altitude'
        | 'velocity_smooth'
        | 'heartrate'
        | 'cadence'
        | 'watts'
        | 'temp'
        | 'moving'
        | 'grade_smooth'
      >,
      key_by_type: boolean,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getSegmentEffortStreams.'
        );
      }
      // verify required parameter 'keys' is not null or undefined
      if (keys === null || keys === undefined) {
        throw new RequiredError(
          'keys',
          'Required parameter keys was null or undefined when calling getSegmentEffortStreams.'
        );
      }
      // verify required parameter 'key_by_type' is not null or undefined
      if (key_by_type === null || key_by_type === undefined) {
        throw new RequiredError(
          'key_by_type',
          'Required parameter key_by_type was null or undefined when calling getSegmentEffortStreams.'
        );
      }
      const localVarPath = `/segment_efforts/{id}/streams`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (keys) {
        localVarQueryParameter['keys'] = keys.join(COLLECTION_FORMATS['csv']);
      }

      if (key_by_type !== undefined) {
        localVarQueryParameter['key_by_type'] = key_by_type;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the given segment's streams. Requires read_all scope for private segments.
     * @summary Get Segment Streams
     * @param {number} id The identifier of the segment.
     * @param {Array<'distance' | 'latlng' | 'altitude'>} keys The types of streams to return.
     * @param {boolean} key_by_type Must be true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSegmentStreams(
      id: number,
      keys: Array<'distance' | 'latlng' | 'altitude'>,
      key_by_type: boolean,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getSegmentStreams.'
        );
      }
      // verify required parameter 'keys' is not null or undefined
      if (keys === null || keys === undefined) {
        throw new RequiredError(
          'keys',
          'Required parameter keys was null or undefined when calling getSegmentStreams.'
        );
      }
      // verify required parameter 'key_by_type' is not null or undefined
      if (key_by_type === null || key_by_type === undefined) {
        throw new RequiredError(
          'key_by_type',
          'Required parameter key_by_type was null or undefined when calling getSegmentStreams.'
        );
      }
      const localVarPath = `/segments/{id}/streams`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (keys) {
        localVarQueryParameter['keys'] = keys.join(COLLECTION_FORMATS['csv']);
      }

      if (key_by_type !== undefined) {
        localVarQueryParameter['key_by_type'] = key_by_type;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * StreamsApi - functional programming interface
 * @export
 */
export const StreamsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Returns the given activity's streams. Requires activity:read scope. Requires activity:read_all scope for Only Me activities.
     * @summary Get Activity Streams
     * @param {number} id The identifier of the activity.
     * @param {Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>} keys Desired stream types.
     * @param {boolean} key_by_type Must be true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivityStreams(
      id: number,
      keys: Array<
        | 'time'
        | 'distance'
        | 'latlng'
        | 'altitude'
        | 'velocity_smooth'
        | 'heartrate'
        | 'cadence'
        | 'watts'
        | 'temp'
        | 'moving'
        | 'grade_smooth'
      >,
      key_by_type: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<StreamSet> {
      const localVarFetchArgs = StreamsApiFetchParamCreator(
        configuration
      ).getActivityStreams(id, keys, key_by_type, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns the given route's streams. Requires read_all scope for private routes.
     * @summary Get Route Streams
     * @param {number} id The identifier of the route.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRouteStreams(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<StreamSet> {
      const localVarFetchArgs = StreamsApiFetchParamCreator(
        configuration
      ).getRouteStreams(id, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a set of streams for a segment effort completed by the authenticated athlete. Requires read_all scope.
     * @summary Get Segment Effort Streams
     * @param {number} id The identifier of the segment effort.
     * @param {Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>} keys The types of streams to return.
     * @param {boolean} key_by_type Must be true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSegmentEffortStreams(
      id: number,
      keys: Array<
        | 'time'
        | 'distance'
        | 'latlng'
        | 'altitude'
        | 'velocity_smooth'
        | 'heartrate'
        | 'cadence'
        | 'watts'
        | 'temp'
        | 'moving'
        | 'grade_smooth'
      >,
      key_by_type: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<StreamSet> {
      const localVarFetchArgs = StreamsApiFetchParamCreator(
        configuration
      ).getSegmentEffortStreams(id, keys, key_by_type, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns the given segment's streams. Requires read_all scope for private segments.
     * @summary Get Segment Streams
     * @param {number} id The identifier of the segment.
     * @param {Array<'distance' | 'latlng' | 'altitude'>} keys The types of streams to return.
     * @param {boolean} key_by_type Must be true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSegmentStreams(
      id: number,
      keys: Array<'distance' | 'latlng' | 'altitude'>,
      key_by_type: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<StreamSet> {
      const localVarFetchArgs = StreamsApiFetchParamCreator(
        configuration
      ).getSegmentStreams(id, keys, key_by_type, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    }
  };
};

/**
 * StreamsApi - factory interface
 * @export
 */
export const StreamsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Returns the given activity's streams. Requires activity:read scope. Requires activity:read_all scope for Only Me activities.
     * @summary Get Activity Streams
     * @param {number} id The identifier of the activity.
     * @param {Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>} keys Desired stream types.
     * @param {boolean} key_by_type Must be true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActivityStreams(
      id: number,
      keys: Array<
        | 'time'
        | 'distance'
        | 'latlng'
        | 'altitude'
        | 'velocity_smooth'
        | 'heartrate'
        | 'cadence'
        | 'watts'
        | 'temp'
        | 'moving'
        | 'grade_smooth'
      >,
      key_by_type: boolean,
      options?: any
    ) {
      return StreamsApiFp(configuration).getActivityStreams(
        id,
        keys,
        key_by_type,
        options
      )(fetch, basePath);
    },
    /**
     * Returns the given route's streams. Requires read_all scope for private routes.
     * @summary Get Route Streams
     * @param {number} id The identifier of the route.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRouteStreams(id: number, options?: any) {
      return StreamsApiFp(configuration).getRouteStreams(id, options)(
        fetch,
        basePath
      );
    },
    /**
     * Returns a set of streams for a segment effort completed by the authenticated athlete. Requires read_all scope.
     * @summary Get Segment Effort Streams
     * @param {number} id The identifier of the segment effort.
     * @param {Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>} keys The types of streams to return.
     * @param {boolean} key_by_type Must be true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSegmentEffortStreams(
      id: number,
      keys: Array<
        | 'time'
        | 'distance'
        | 'latlng'
        | 'altitude'
        | 'velocity_smooth'
        | 'heartrate'
        | 'cadence'
        | 'watts'
        | 'temp'
        | 'moving'
        | 'grade_smooth'
      >,
      key_by_type: boolean,
      options?: any
    ) {
      return StreamsApiFp(configuration).getSegmentEffortStreams(
        id,
        keys,
        key_by_type,
        options
      )(fetch, basePath);
    },
    /**
     * Returns the given segment's streams. Requires read_all scope for private segments.
     * @summary Get Segment Streams
     * @param {number} id The identifier of the segment.
     * @param {Array<'distance' | 'latlng' | 'altitude'>} keys The types of streams to return.
     * @param {boolean} key_by_type Must be true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSegmentStreams(
      id: number,
      keys: Array<'distance' | 'latlng' | 'altitude'>,
      key_by_type: boolean,
      options?: any
    ) {
      return StreamsApiFp(configuration).getSegmentStreams(
        id,
        keys,
        key_by_type,
        options
      )(fetch, basePath);
    }
  };
};

/**
 * StreamsApi - object-oriented interface
 * @export
 * @class StreamsApi
 * @extends {BaseAPI}
 */
export class StreamsApi extends BaseAPI {
  /**
   * Returns the given activity's streams. Requires activity:read scope. Requires activity:read_all scope for Only Me activities.
   * @summary Get Activity Streams
   * @param {number} id The identifier of the activity.
   * @param {Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>} keys Desired stream types.
   * @param {boolean} key_by_type Must be true.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StreamsApi
   */
  public getActivityStreams(
    id: number,
    keys: Array<
      | 'time'
      | 'distance'
      | 'latlng'
      | 'altitude'
      | 'velocity_smooth'
      | 'heartrate'
      | 'cadence'
      | 'watts'
      | 'temp'
      | 'moving'
      | 'grade_smooth'
    >,
    key_by_type: boolean,
    options?: any
  ) {
    return StreamsApiFp(this.configuration).getActivityStreams(
      id,
      keys,
      key_by_type,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns the given route's streams. Requires read_all scope for private routes.
   * @summary Get Route Streams
   * @param {number} id The identifier of the route.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StreamsApi
   */
  public getRouteStreams(id: number, options?: any) {
    return StreamsApiFp(this.configuration).getRouteStreams(id, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns a set of streams for a segment effort completed by the authenticated athlete. Requires read_all scope.
   * @summary Get Segment Effort Streams
   * @param {number} id The identifier of the segment effort.
   * @param {Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>} keys The types of streams to return.
   * @param {boolean} key_by_type Must be true.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StreamsApi
   */
  public getSegmentEffortStreams(
    id: number,
    keys: Array<
      | 'time'
      | 'distance'
      | 'latlng'
      | 'altitude'
      | 'velocity_smooth'
      | 'heartrate'
      | 'cadence'
      | 'watts'
      | 'temp'
      | 'moving'
      | 'grade_smooth'
    >,
    key_by_type: boolean,
    options?: any
  ) {
    return StreamsApiFp(this.configuration).getSegmentEffortStreams(
      id,
      keys,
      key_by_type,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns the given segment's streams. Requires read_all scope for private segments.
   * @summary Get Segment Streams
   * @param {number} id The identifier of the segment.
   * @param {Array<'distance' | 'latlng' | 'altitude'>} keys The types of streams to return.
   * @param {boolean} key_by_type Must be true.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StreamsApi
   */
  public getSegmentStreams(
    id: number,
    keys: Array<'distance' | 'latlng' | 'altitude'>,
    key_by_type: boolean,
    options?: any
  ) {
    return StreamsApiFp(this.configuration).getSegmentStreams(
      id,
      keys,
      key_by_type,
      options
    )(this.fetch, this.basePath);
  }
}

/**
 * UploadsApi - fetch parameter creator
 * @export
 */
export const UploadsApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Uploads a new data file to create an activity from. Requires activity:write scope.
     * @summary Upload Activity
     * @param {any} [file] The uploaded file.
     * @param {string} [name] The desired name of the resulting activity.
     * @param {string} [description] The desired description of the resulting activity.
     * @param {string} [trainer] Whether the resulting activity should be marked as having been performed on a trainer.
     * @param {string} [commute] Whether the resulting activity should be tagged as a commute.
     * @param {'fit' | 'fit.gz' | 'tcx' | 'tcx.gz' | 'gpx' | 'gpx.gz'} [data_type] The format of the uploaded file.
     * @param {string} [external_id] The desired external identifier of the resulting activity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUpload(
      file?: any,
      name?: string,
      description?: string,
      trainer?: string,
      commute?: string,
      data_type?: 'fit' | 'fit.gz' | 'tcx' | 'tcx.gz' | 'gpx' | 'gpx.gz',
      external_id?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/uploads`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new url.URLSearchParams();

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      if (file !== undefined) {
        localVarFormParams.set('file', file as any);
      }

      if (name !== undefined) {
        localVarFormParams.set('name', name as any);
      }

      if (description !== undefined) {
        localVarFormParams.set('description', description as any);
      }

      if (trainer !== undefined) {
        localVarFormParams.set('trainer', trainer as any);
      }

      if (commute !== undefined) {
        localVarFormParams.set('commute', commute as any);
      }

      if (data_type !== undefined) {
        localVarFormParams.set('data_type', data_type as any);
      }

      if (external_id !== undefined) {
        localVarFormParams.set('external_id', external_id as any);
      }

      localVarHeaderParameter['Content-Type'] =
        'application/x-www-form-urlencoded';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      localVarRequestOptions.body = localVarFormParams.toString();

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns an upload for a given identifier. Requires activity:write scope.
     * @summary Get Upload
     * @param {number} uploadId The identifier of the upload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUploadById(uploadId: number, options: any = {}): FetchArgs {
      // verify required parameter 'uploadId' is not null or undefined
      if (uploadId === null || uploadId === undefined) {
        throw new RequiredError(
          'uploadId',
          'Required parameter uploadId was null or undefined when calling getUploadById.'
        );
      }
      const localVarPath = `/uploads/{uploadId}`.replace(
        `{${'uploadId'}}`,
        encodeURIComponent(String(uploadId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication strava_oauth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === 'function'
            ? configuration.accessToken('strava_oauth', [])
            : configuration.accessToken;
        localVarHeaderParameter['Authorization'] =
          'Bearer ' + localVarAccessTokenValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * UploadsApi - functional programming interface
 * @export
 */
export const UploadsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Uploads a new data file to create an activity from. Requires activity:write scope.
     * @summary Upload Activity
     * @param {any} [file] The uploaded file.
     * @param {string} [name] The desired name of the resulting activity.
     * @param {string} [description] The desired description of the resulting activity.
     * @param {string} [trainer] Whether the resulting activity should be marked as having been performed on a trainer.
     * @param {string} [commute] Whether the resulting activity should be tagged as a commute.
     * @param {'fit' | 'fit.gz' | 'tcx' | 'tcx.gz' | 'gpx' | 'gpx.gz'} [data_type] The format of the uploaded file.
     * @param {string} [external_id] The desired external identifier of the resulting activity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUpload(
      file?: any,
      name?: string,
      description?: string,
      trainer?: string,
      commute?: string,
      data_type?: 'fit' | 'fit.gz' | 'tcx' | 'tcx.gz' | 'gpx' | 'gpx.gz',
      external_id?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Upload> {
      const localVarFetchArgs = UploadsApiFetchParamCreator(
        configuration
      ).createUpload(
        file,
        name,
        description,
        trainer,
        commute,
        data_type,
        external_id,
        options
      );
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns an upload for a given identifier. Requires activity:write scope.
     * @summary Get Upload
     * @param {number} uploadId The identifier of the upload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUploadById(
      uploadId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Upload> {
      const localVarFetchArgs = UploadsApiFetchParamCreator(
        configuration
      ).getUploadById(uploadId, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    }
  };
};

/**
 * UploadsApi - factory interface
 * @export
 */
export const UploadsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Uploads a new data file to create an activity from. Requires activity:write scope.
     * @summary Upload Activity
     * @param {any} [file] The uploaded file.
     * @param {string} [name] The desired name of the resulting activity.
     * @param {string} [description] The desired description of the resulting activity.
     * @param {string} [trainer] Whether the resulting activity should be marked as having been performed on a trainer.
     * @param {string} [commute] Whether the resulting activity should be tagged as a commute.
     * @param {'fit' | 'fit.gz' | 'tcx' | 'tcx.gz' | 'gpx' | 'gpx.gz'} [data_type] The format of the uploaded file.
     * @param {string} [external_id] The desired external identifier of the resulting activity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUpload(
      file?: any,
      name?: string,
      description?: string,
      trainer?: string,
      commute?: string,
      data_type?: 'fit' | 'fit.gz' | 'tcx' | 'tcx.gz' | 'gpx' | 'gpx.gz',
      external_id?: string,
      options?: any
    ) {
      return UploadsApiFp(configuration).createUpload(
        file,
        name,
        description,
        trainer,
        commute,
        data_type,
        external_id,
        options
      )(fetch, basePath);
    },
    /**
     * Returns an upload for a given identifier. Requires activity:write scope.
     * @summary Get Upload
     * @param {number} uploadId The identifier of the upload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUploadById(uploadId: number, options?: any) {
      return UploadsApiFp(configuration).getUploadById(uploadId, options)(
        fetch,
        basePath
      );
    }
  };
};

/**
 * UploadsApi - object-oriented interface
 * @export
 * @class UploadsApi
 * @extends {BaseAPI}
 */
export class UploadsApi extends BaseAPI {
  /**
   * Uploads a new data file to create an activity from. Requires activity:write scope.
   * @summary Upload Activity
   * @param {any} [file] The uploaded file.
   * @param {string} [name] The desired name of the resulting activity.
   * @param {string} [description] The desired description of the resulting activity.
   * @param {string} [trainer] Whether the resulting activity should be marked as having been performed on a trainer.
   * @param {string} [commute] Whether the resulting activity should be tagged as a commute.
   * @param {'fit' | 'fit.gz' | 'tcx' | 'tcx.gz' | 'gpx' | 'gpx.gz'} [data_type] The format of the uploaded file.
   * @param {string} [external_id] The desired external identifier of the resulting activity.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UploadsApi
   */
  public createUpload(
    file?: any,
    name?: string,
    description?: string,
    trainer?: string,
    commute?: string,
    data_type?: 'fit' | 'fit.gz' | 'tcx' | 'tcx.gz' | 'gpx' | 'gpx.gz',
    external_id?: string,
    options?: any
  ) {
    return UploadsApiFp(this.configuration).createUpload(
      file,
      name,
      description,
      trainer,
      commute,
      data_type,
      external_id,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns an upload for a given identifier. Requires activity:write scope.
   * @summary Get Upload
   * @param {number} uploadId The identifier of the upload.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UploadsApi
   */
  public getUploadById(uploadId: number, options?: any) {
    return UploadsApiFp(this.configuration).getUploadById(uploadId, options)(
      this.fetch,
      this.basePath
    );
  }
}
